[
  {
    "code": "bool isMatch(char* s, char* p); bool matchStar(char ch, char* s, char* p); bool matchStar(char ch, char* s, char* p) { do { if (isMatch(s, p)) return true; } while (*s != '\\0' && (*s++ == ch || ch == '.')); return false; } bool isMatch(char* s, char* p) { if (*p == '\\0') return *s == '\\0'; if (p[1] == '*') return matchStar(p[0], s, p + 2); if (*s != '\\0' && (p[0] == '.' || *p == *s)) { return isMatch(s + 1, p + 1); } return false; }",
    "label": 0
  },
  {
    "code": "int numOfSubarrays(int* arr, int arrSize){ int result = 0; int curSumm = 0; int currOddSumms = 0; int currEvenSumm = 0; int modulo = 1000000000 + 7; for(int i = 0; i < arrSize; i++){ curSumm += arr[i]; if (curSumm % 2 == 0){ currEvenSumm++; result = (result + currOddSumms) % modulo; } else { currOddSumms++; result = (result + 1 + currEvenSumm) % modulo; } } return result % modulo; }",
    "label": 0
  },
  {
    "code": "int search(int *nums, int numsSize, int target) { int low = 0, high = numsSize - 1; while (low <= high) { int mid = low + (high - low) / 2; if (target > nums[mid]) { low = mid + 1; } else if (target < nums[mid]) { high = mid - 1; } else { return mid; } } return -1; } int cmpint(const void *a, const void *b) { return *(int *)a - *(int *)b; } int search(int *nums, int numsSize, int target) { int *ret = bsearch(&target, nums, numsSize, sizeof(int), cmpint); if (ret) return (ret - nums); else return -1; }",
    "label": 0
  },
  {
    "code": "int rangeSumBST(struct TreeNode *root, int L, int R) { if (root == NULL) { return 0; } else if (root->val >= L && root->val <= R) { return root->val + rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R); } else { return rangeSumBST(root->left, L, R) + rangeSumBST(root->right, L, R); } }",
    "label": 0
  },
  {
    "code": "void rotate(int *nums, int numsSize, int k) { for (int i = 1; i <= k; i++) { int j; int lastElement; lastElement = nums[numsSize - 1]; for (j = numsSize - 1; j > 0; j--) { nums[j] = nums[j - 1]; } nums[0] = lastElement; } }",
    "label": 0
  },
  {
    "code": "int* minOperations(char* boxes, int* returnSize){ int leftOnes = 0; int leftCommonDistance = 0; int rightOnes = 0; int rightCommonDistance = 0; int boxesLength = strlen(boxes); *returnSize = boxesLength; int* result = malloc(boxesLength * sizeof(int)); for (int i = 0; i < boxesLength; i++){ if (boxes[i] == '1'){ rightOnes += 1; rightCommonDistance += i; } } for (int i = 0; i < boxesLength; i++){ if (boxes[i] == '1'){ rightOnes -= 1; leftOnes += 1; } result[i] = rightCommonDistance + leftCommonDistance; rightCommonDistance -= rightOnes; leftCommonDistance += leftOnes; } return result; }",
    "label": 0
  },
  {
    "code": "struct TreeNode *insertIntoBST(struct TreeNode *root, int val) { if (root == NULL) { struct TreeNode *new_val = malloc(sizeof(struct TreeNode)); new_val->val = val; new_val->left = new_val->right = NULL; return new_val; } else { if (root->val >= val) root->left = insertIntoBST(root->left, val); else root->right = insertIntoBST(root->right, val); } return root; }",
    "label": 0
  },
  {
    "code": "double powPositive(double x, int n){ if (n == 1){ return x; } double val = powPositive(x, n / 2); double result = val * val; if (n & 1 > 0){ result *= x; } return result; } double myPow(double x, int n){ if (n == 0){ return 1; } const int LOWER_BOUND = -2147483648; if (n == LOWER_BOUND){ return 1 / (powPositive(x, -(n + 1)) * x); } if (n < 0){ return 1 / powPositive(x, -n); } return powPositive(x, n); }",
    "label": 0
  },
  {
    "code": "#define min(X, Y) ((X) < (Y) ? (X) : (Y)) int intersectionSize(int p11, int p12, int p21, int p22){ if (p11 >= p22 || p12 <= p21){ return 0; } if (p11 < p21){ return min(p12 - p21, p22 - p21); } return min(p22 - p11, p12 - p11); } int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2){ int areaA = (ay2 - ay1) * (ax2 - ax1); int areaB = (by2 - by1) * (bx2 - bx1); int areaInteresection = intersectionSize(ax1, ax2, bx1, bx2) * intersectionSize(ay1, ay2, by1, by2); return areaA + areaB - areaInteresection; }",
    "label": 0
  },
  {
    "code": "bool isVowel(char chr){ switch(chr){ case 'a': case 'e': case 'i': case 'o': case 'u': case 'A': case 'E': case 'I': case 'O': case 'U': return true; } return false; } bool halvesAreAlike(char * s){ int lenS = strlen(s); int halfVowels = 0; int currVowels = 0; for (int i = 0; i < lenS; i++){ if (isVowel(s[i])){ currVowels++; } if (2 * (i + 1) == lenS){ halfVowels = currVowels; } } return 2 * halfVowels == currVowels; }",
    "label": 0
  },
  {
    "code": "int *sortedSquares(int *A, int ASize, int *returnSize) { int i, start = 0, end = ASize - 1; int *res = malloc(ASize * sizeof(int)); *returnSize = ASize; for (i = ASize - 1; i >= 0; i--) { if (abs(A[start]) > A[end]) { res[i] = A[start] * A[start]; start++; } else { res[i] = A[end] * A[end]; end--; } } return res; } int cmpval(const void *a, const void *b) { return *(int *)a - *(int *)b; } int *sortedSquares(int *A, int ASize, int *returnSize) { int *res = malloc(ASize * sizeof(int)); for (int i = 0; i < ASize; i++) res[i] = A[i] * A[i]; *returnSize = ASize; qsort(res, ASize, sizeof(int), cmpval); return res; }",
    "label": 0
  },
  {
    "code": "struct ListNode *middleNode(struct ListNode *head) { struct ListNode *fast, *slow; fast = slow = head; while (fast && fast->next) { slow = slow->next; fast = fast->next->next; } return slow; }",
    "label": 0
  },
  {
    "code": "int firstUniqChar(char *s) { int *arr = calloc(256, sizeof(int)); int i; for (i = 0; i < strlen(s); i++) arr[s[i]] = arr[s[i]] + 1; for (i = 0; i < strlen(s); i++) { if (arr[s[i]] == 1) return i; } return -1; }",
    "label": 0
  },
  {
    "code": "int divide(int dividend, int divisor) { int sign = 1; long int output = 0; if (dividend < 0) { sign *= -1; } else { dividend *= -1; } if (divisor < 0) { sign *= -1; } else { divisor *= -1; } while (dividend <= divisor) { long int tmp = 0; long int div = divisor; while (dividend <= div) { tmp += (tmp + 1); dividend -= div; div += div; } if (output >= INT_MAX) { if (sign == -1) { return INT_MIN; } else { return INT_MAX; } } output += tmp; } return output * sign; }",
    "label": 0
  },
  {
    "code": "#include <stdio.h> #include <stdlib.h> static void swap(int *a, int *b){ int t=*a; *a=*b; *b=t; } static int rand_between(int l, int r){ return l + rand() % (r - l + 1); } static int partition_lomuto(int a[], int l, int r){ int pivot = a[r]; int i = l - 1; for(int j=l;j<r;++j){ if(a[j] <= pivot){ ++i; swap(&a[i], &a[j]); } } swap(&a[i+1], &a[r]); return i+1; } void quickSort(int a[], int l, int r){ if(l < r){ int sel = rand_between(l, r); swap(&a[sel], &a[r]); int p = partition_lomuto(a,l,r); quickSort(a,l,p-1); quickSort(a,p+1,r); } } #ifdef DEMO int main(){ int a[]={4,2,2,8,3,3,1,5,7,6}; int n=sizeof(a)/sizeof(a[0]); srand(7); quickSort(a,0,n-1); for(int i=0;i<n;i++) printf(\"%d \", a[i]); return 0; } #endif",
    "label": 1
  },
  {
    "code": "bool isUnivalTree(struct TreeNode *root) { if (root == NULL) return 1; if (root->left) { if (root->left->val != root->val) return 0; } if (root->right) { if (root->right->val != root->val) return 0; } return isUnivalTree(root->left) && isUnivalTree(root->right); }",
    "label": 0
  },
  {
    "code": "typedef struct stack{ int price; int index; struct stack* previous; } Stack; typedef struct { int index; Stack* stackPointer; Stack* sentry; } StockSpanner; StockSpanner* stockSpannerCreate() { Stack* sentry = (Stack *)malloc(sizeof(Stack)); StockSpanner* result = (StockSpanner *)malloc(sizeof(StockSpanner)); result->index = 0; result->sentry = sentry; result->stackPointer = sentry; return result; } int stockSpannerNext(StockSpanner* obj, int price) { while(obj->stackPointer != obj->sentry && obj->stackPointer->price <= price){ Stack* currStackPointer = obj->stackPointer; obj->stackPointer = obj->stackPointer->previous; free(currStackPointer); } obj->index += 1; int result = obj->index; if (obj->stackPointer != obj->sentry){ result -= obj->stackPointer->index; } Stack* newStackItem = (Stack *)malloc(sizeof(Stack)); newStackItem->index = obj->index; newStackItem->price = price; newStackItem->previous = obj->stackPointer; obj->stackPointer = newStackItem; return result; } void stockSpannerFree(StockSpanner* obj) { while(obj->stackPointer != obj->sentry){ Stack* currStackPointer = obj->stackPointer; obj->stackPointer = obj->stackPointer->previous; free(currStackPointer); } free(obj->sentry); free(obj); }",
    "label": 0
  },
  {
    "code": "int *sortArrayByParity(int *A, int ASize, int *returnSize) { int *retArr = malloc(ASize * sizeof(int)); int oddIndex = ASize - 1; int evenIndex = 0; *returnSize = ASize; for (int i = 0; i < ASize; i++) { if (A[i] % 2 == 0) { retArr[evenIndex] = A[i]; evenIndex++; } else { retArr[oddIndex] = A[i]; oddIndex--; } } return retArr; }",
    "label": 0
  },
  {
    "code": "struct ListNode *removeElements(struct ListNode *head, int val) { if (head == NULL) return NULL; if (head->val == val) { return removeElements(head->next, val); } else { head->next = removeElements(head->next, val); } return head; }",
    "label": 0
  },
  {
    "code": "int** onesMinusZeros(int** grid, int gridSize, int* gridColSize, int* returnSize, int** returnColumnSizes){ int n = gridSize; int m = gridColSize[0]; int** result = malloc(gridSize * sizeof(int*)); for (int i = 0; i < n; i++){ result[i] = malloc(m * sizeof(int)); } int* onesRows = calloc(n, sizeof(int)); int* onesCols = calloc(m, sizeof(int)); for (int i = 0; i < n; i++){ for (int j = 0; j < m; j++){ if (grid[i][j] == 1){ onesRows[i] += 1; onesCols[j] += 1; } } } for (int i = 0; i < gridSize; i++){ for (int j = 0; j < gridColSize[i]; j++){ result[i][j] = onesRows[i] + onesCols[j] - (m - onesRows[i]) - (n - onesCols[j]); } } free(onesRows); free(onesCols); *returnSize = gridSize; *returnColumnSizes = gridColSize; return result; }",
    "label": 0
  },
  {
    "code": "int uniquePaths(int m, int n) { int dp[m][n]; for (int column = 0; column < n; column++) { dp[0][column] = 1; } for (int row = 1; row < m; row++) { dp[row][0] = 1; } for (int row = 1; row < m; row++) { for (int column = 1; column < n; column++) { dp[row][column] = dp[row - 1][column] + dp[row][column - 1]; } } return dp[m - 1][n - 1]; }",
    "label": 0
  },
  {
    "code": "int singleNumber(int *nums, int numsSize) { int i, result = 0; for (i = 0; i < numsSize; i++) result = result ^ nums[i]; return result; }",
    "label": 0
  },
  {
    "code": "uint32_t reverseBits(uint32_t n) { uint TotalBits = 32; uint32_t reverse_int = 0; uint i; for (i = 0; i < TotalBits; i++) { if ((n & (UINT32_C(1) << i))) reverse_int = reverse_int | (UINT32_C(1) << (TotalBits - 1 - i)); } return reverse_int; }",
    "label": 0
  },
  {
    "code": "#include <stdio.h> void sliding_max_blocks(int a[], int n, int k, int out[]){ int left[n], right[n]; for(int i=0;i<n;i++){ if(i%k==0) left[i]=a[i]; else left[i] = (left[i-1]>a[i])?left[i-1]:a[i]; } for(int i=n-1;i>=0;i--){ if((i+1)%k==0 || i==n-1) right[i]=a[i]; else right[i] = (right[i+1]>a[i])?right[i+1]:a[i]; } for(int i=0;i<=n-k;i++){ int j=i+k-1; out[i] = right[i] > left[j] ? right[i] : left[j]; } } #ifdef DEMO int main(){ int a[]={1,3,-1,-3,5,3,6,7}; int n=8,k=3, out[100]; sliding_max_blocks(a,n,k,out); for(int i=0;i<=n-k;i++) printf(\"%d \", out[i]); return 0; } #endif",
    "label": 1
  },
  {
    "code": "struct ListNode *addTwoNumbers(struct ListNode *l1, struct ListNode *l2) { struct ListNode *head = NULL; struct ListNode *walk = NULL; struct ListNode *tmp = NULL; int carry = 0; int val1 = 0; int val2 = 0; int val = 0; while (l1 != NULL || l2 != NULL || carry) { val1 = 0; val2 = 0; val = 0; if (l1) { val1 = l1->val; l1 = l1->next; } if (l2) { val2 = l2->val; l2 = l2->next; } val = carry + val1 + val2; carry = val / 10; tmp = malloc(sizeof(struct ListNode)); tmp->val = val % 10; tmp->next = NULL; if (!head) { head = walk = tmp; } else { walk->next = tmp; walk = walk->next; } } return head; }",
    "label": 0
  },
  {
    "code": "int tribonacci(int n){ int t0 = 0; int t1 = 1; int t2 = 1; if (n == 0) { return t0; } if (n == 1){ return t1; } if (n == 2){ return t2; } for (int i = 0; i < n - 2; i++){ int nextT = t0 + t1 + t2; t0 = t1; t1 = t2; t2 = nextT; } return t2; }",
    "label": 0
  },
  {
    "code": "void swap(int *x, int *y){ if (x==y) return; *x = *x + *y; *y= *x - *y; *x= *x - *y; } void sortColors(int* arr, int n){ int start=0, mid=0, end=n-1; while(mid<=end){ if(arr[mid]==1) mid++; else if(arr[mid]==0){ swap(&arr[mid],&arr[start]); mid++; start++; } else{ swap(&arr[mid],&arr[end]); end--; } } }",
    "label": 0
  },
  {
    "code": "bool isPowerOfTwo(int n){ return (n > 0) && ((n & (n - 1)) == 0); }",
    "label": 0
  },
  {
    "code": "#define min(x,y)(((x)<(y))?(x):(y)) int minPathCost(int** grid, int gridSize, int* gridColSize, int** moveCost, int moveCostSize, int* moveCostColSize){ int* dp = (int*)calloc(gridColSize[0], sizeof(int)); int* newDp = (int*)calloc(gridColSize[0], sizeof(int)); for(int i = 0; i < gridSize - 1; i++){ int currGridColSize = gridColSize[i]; for(int j = 0; j < currGridColSize; j++){ newDp[j] = -1; } for(int j = 0; j < currGridColSize; j++){ int currGridItem = grid[i][j]; for(int z = 0; z < currGridColSize; z++){ int currMoveCost = dp[j] + moveCost[currGridItem][z] + currGridItem; newDp[z] = (newDp[z] == -1) ? currMoveCost : min(newDp[z], currMoveCost); } } for(int j = 0; j < currGridColSize; j++){ dp[j] = newDp[j]; } } int minValue = dp[0] + grid[gridSize - 1][0]; for(int j = 1; j < gridColSize[0]; j++){ minValue = min(minValue, dp[j] + grid[gridSize - 1][j]); } free(dp); free(newDp); return minValue; }",
    "label": 0
  },
  {
    "code": "struct TreeNode *buildBST(struct ListNode *head, struct ListNode *tail) { if (head == tail) return NULL; struct ListNode *slow = head, *fast = head; while (fast != tail && fast->next != tail) { fast = fast->next->next; slow = slow->next; } struct TreeNode *node = malloc(sizeof(struct TreeNode)); node->val = slow->val; node->left = buildBST(head, slow); node->right = buildBST(slow->next, tail); return node; } struct TreeNode *sortedListToBST(struct ListNode *head) { if (!head) return NULL; else return buildBST(head, NULL); }",
    "label": 0
  },
  {
    "code": "#define min(X, Y) ((X) < (Y) ? (X) : (Y)) int minimumDeletions(char * s){ int len = strlen(s); int aStateValue = s[0] == 'b'; int bStateValue = 0; int newAStateValue; int newBStateValue; for(int i = 1; i < len; i++){ newAStateValue = aStateValue + (s[i] == 'b'); newBStateValue = min( aStateValue, bStateValue + (s[i] == 'a') ); aStateValue = newAStateValue; bStateValue = newBStateValue; } return min(aStateValue, bStateValue); }",
    "label": 0
  },
  {
    "code": "bool check(int* nums, int numsSize){ if (numsSize == 1) { return true; } bool wasShift = false; for(int i = 1; i < numsSize; i++) { if (nums[i - 1] > nums[i]) { if (wasShift) { return false; } wasShift = true; } } return !wasShift || nums[0] >= nums[numsSize-1]; }",
    "label": 0
  },
  {
    "code": "int compare(const int* i, const int* j) { return *i - *j; } int maximumBags(int* capacity, int capacitySize, int* rocks, int rocksSize, int additionalRocks) { int* capacityLeft = malloc(capacitySize * sizeof(int)); for (int i = 0; i < capacitySize; i++) { capacityLeft[i] = capacity[i] - rocks[i]; } qsort(capacityLeft, capacitySize, sizeof (int), (int(*) (const void*, const void*)) compare); int bags = 0; for (int i = 0; i < capacitySize; i++) { if (additionalRocks < capacityLeft[i]){ break; } additionalRocks -= capacityLeft[i]; bags++; } free(capacityLeft); return bags; }",
    "label": 0
  },
  {
    "code": "#include <crypto/internal/scompress.h> #include <linux/init.h> #include <linux/module.h> #include <linux/sw842.h> static void *crypto842_alloc_ctx(void) { void *ctx; ctx = kmalloc(SW842_MEM_COMPRESS, GFP_KERNEL); if (!ctx) return ERR_PTR(-ENOMEM); return ctx; } static void crypto842_free_ctx(void *ctx) { kfree(ctx); } static int crypto842_scompress(struct crypto_scomp *tfm, const u8 *src, unsigned int slen, u8 *dst, unsigned int *dlen, void *ctx) { return sw842_compress(src, slen, dst, dlen, ctx); } static int crypto842_sdecompress(struct crypto_scomp *tfm, const u8 *src, unsigned int slen, u8 *dst, unsigned int *dlen, void *ctx) { return sw842_decompress(src, slen, dst, dlen); } static struct scomp_alg scomp = { .streams = { .alloc_ctx = crypto842_alloc_ctx, .free_ctx = crypto842_free_ctx, }, .compress = crypto842_scompress, .decompress = crypto842_sdecompress, .base = { .cra_name = \"842\", .cra_driver_name = \"842-scomp\", .cra_priority = 100, .cra_module = THIS_MODULE, } }; static int __init crypto842_mod_init(void) { return crypto_register_scomp(&scomp); } module_init(crypto842_mod_init); static void __exit crypto842_mod_exit(void) { crypto_unregister_scomp(&scomp); } module_exit(crypto842_mod_exit); MODULE_LICENSE(\"GPL\"); MODULE_DESCRIPTION(\"842 Software Compression Algorithm\"); MODULE_ALIAS_CRYPTO(\"842\"); MODULE_ALIAS_CRYPTO(\"842-generic\"); MODULE_AUTHOR(\"Dan Streetman <ddstreet@ieee.org>\");",
    "label": 0
  },
  {
    "code": "#include <stdio.h> #include <stdlib.h> #define MAXE 100 int adj5[50][50], indeg5[50]; int heap5[50], sz5=0; void pushHeap(int x){ heap5[++sz5]=x; for(int i=sz5;i>1 && heap5[i]<heap5[i/2];i/=2){ int t=heap5[i]; heap5[i]=heap5[i/2]; heap5[i/2]=t; } } int popHeap(){ int ret=heap5[1]; heap5[1]=heap5[sz5--]; for(int i=1;;){ int l=i*2,r=i*2+1,m=i; if(l<=sz5 && heap5[l]<heap5[m]) m=l; if(r<=sz5 && heap5[r]<heap5[m]) m=r; if(m==i) break; int t=heap5[i]; heap5[i]=heap5[m]; heap5[m]=t; i=m; } return ret; } #ifdef DEMO int main(){ int n=6; int e[][2]={{5,2},{5,0},{4,0},{4,1},{2,3},{3,1}}; for(int i=0;i<n;i++) for(int j=0;j<n;j++) adj5[i][j]=0; for(int i=0;i<6;i++){ adj5[e[i][0]][e[i][1]]=1; indeg5[e[i][1]]++; } for(int i=0;i<n;i++) if(indeg5[i]==0) pushHeap(i); while(sz5){ int u=popHeap(); printf(\"%d \", u); for(int v=0;v<n;v++) if(adj5[u][v] && --indeg5[v]==0) pushHeap(v); } return 0; } #endif",
    "label": 1
  },
  {
    "code": "int distanceBetweenBusStops(int *distance, int distanceSize, int start, int destination) { int sum1 = 0, sum2 = 0; if (start > destination) { int tmp = start; start = destination; destination = tmp; } for (auto i = 0; i < distanceSize; ++i) { if (i >= start && i < destination) sum1 += distance[i]; else sum2 += distance[i]; } return sum1 < sum2 ? sum1 : sum2; }",
    "label": 0
  },
  {
    "code": "struct TreeNode *invertTree(struct TreeNode *root) { struct TreeNode *tmp; if (root == NULL) return NULL; tmp = root->left; root->left = root->right; root->right = tmp; invertTree(root->left); invertTree(root->right); return root; }",
    "label": 0
  },
  {
    "code": "char *countAndSay(int n) { double result = 1.0; for (int i = 0; i < n - 1; i++) { result *= 1.4; } int k, j, count, convert = (int)result; char *arr = malloc(convert + 4); arr[0] = '1'; arr[1] = '\\0'; for (int i = 2, length; i <= n; i++) { length = strlen(arr); char newArr[length * 2]; strcpy(newArr, arr); k = 0; j = 0; count = 1; while (newArr[j] != '\\0') { if (newArr[j] == newArr[j + 1]) { count++; j++; } else { arr[k] = (48 + count); arr[k + 1] = newArr[j]; arr[k + 2] = '\\0'; j++; k += 2; count = 1; } } } return arr; }",
    "label": 0
  },
  {
    "code": "struct ListNode *reverseList(struct ListNode *head) { struct ListNode *res = NULL; while (head) { struct ListNode *pre_node = head; head = head->next; pre_node->next = res; res = pre_node; } return res; }",
    "label": 0
  },
  {
    "code": "#include <stdio.h> #include <stdlib.h> typedef struct Node{ int v; struct Node* nxt; } Node; Node* adj7[100]; int visited7[100], result7[100], idx7=0; void push(Node** head, int v){ Node* n=(Node*)malloc(sizeof(Node)); n->v=v; n->nxt=*head; *head=n; } void topo_dfs_iter(int start, int n){ int stack[100], top=-1, done[100]={0}; stack[++top]=start; while(top>=0){ int u=stack[top]; if(!visited7[u]){ visited7[u]=1; Node* cur=adj7[u]; while(cur){ if(!visited7[cur->v]) stack[++top]=cur->v; cur=cur->nxt; } } else { if(!done[u]){ result7[idx7++]=u; done[u]=1; } top--; } } } #ifdef DEMO int main(){ int n=6; int edges[][2]={{5,0},{5,2},{4,0},{4,1},{2,3},{3,1}}; for(int i=0;i<6;i++) adj7[i]=NULL; for(int i=0;i<6;i++) push(&adj7[edges[i][0]],edges[i][1]); for(int i=0;i<n;i++) if(!visited7[i]) topo_dfs_iter(i,n); for(int i=idx7-1;i>=0;i--) printf(\"%d \", result7[i]); printf(\"\\n\"); return 0; } #endif",
    "label": 1
  },
  {
    "code": "#include <stdio.h> void rotate90_layers(int m[][100], int n){ for(int layer=0; layer<n/2; ++layer){ int first = layer, last = n - 1 - layer; for(int i=first; i<last; ++i){ int offset = i - first; int top = m[first][i]; m[first][i] = m[last - offset][first]; m[last - offset][first] = m[last][last - offset]; m[last][last - offset] = m[i][last]; m[i][last] = top; } } } #ifdef DEMO int main(){ int n=4; int a[100][100]={{1,2,3,4},{5,6,7,8},{9,10,11,12},{13,14,15,16}}; rotate90_layers(a,n); for(int i=0;i<n;i++){ for(int j=0;j<n;j++) printf(\"%d \",a[i][j]); printf(\"\\n\"); } return 0; } #endif",
    "label": 1
  },
  {
    "code": "int pairSum(struct ListNode* head) { struct ListNode* dup = head; int count = 0, i = 0, max = 0; while (head != NULL) { count++; head = head->next; } int* arr = malloc(count * sizeof(int)); while (dup != NULL) { arr[i++] = dup->val; dup = dup->next; } for (i = 0; i < count / 2; ++i) { if (arr[i] + arr[count - i - 1] > max) max = arr[i] + arr[count - i - 1]; } return max; }",
    "label": 0
  },
  {
    "code": "struct TreeNode* trimBST(struct TreeNode* root, int low, int high){ if (root == NULL){ return NULL; } if (root->val > high){ return trimBST(root->left, low, high); } if (root->val < low){ return trimBST(root->right, low, high); } root->left = trimBST(root->left, low, high); root->right = trimBST(root->right, low, high); return root; }",
    "label": 0
  },
  {
    "code": "#include <stdio.h> int search_rotated(int a[], int n, int target){ int lo=0, hi=n-1; while(lo<=hi){ int mid=lo+(hi-lo)/2; if(a[mid]==target) return mid; if(a[lo] <= a[mid]){ if(a[lo] <= target && target < a[mid]) hi = mid-1; else lo = mid+1; }else{ if(a[mid] < target && target <= a[hi]) lo = mid+1; else hi = mid-1; } } return -1; } #ifdef DEMO int main(){ int a[]={4,5,6,7,0,1,2}; printf(\"%d\\n\", search_rotated(a,7,0)); printf(\"%d\\n\", search_rotated(a,7,3)); return 0; } #endif",
    "label": 1
  },
  {
    "code": "bool isValid(char *s) { int i, k = 0, len = strlen(s); char *store = calloc(len, sizeof(char)); for (i = 0; s[i] != '\\0'; i++) { switch (s[i]) { case '(': case '{': case '[': store[k++] = s[i]; break; case ')': if (k < 1 || store[--k] != '(') goto out; break; case '}': if (k < 1 || store[--k] != '{') goto out; break; case ']': if (k < 1 || store[--k] != '[') goto out; break; } } out: free(store); return s[i] == '\\0' && k == 0; }",
    "label": 0
  },
  {
    "code": "#include <stdio.h> long count_subarrays_k_n2(int a[], int n, int k){ long pref[1005]; pref[0]=0; for(int i=0;i<n;i++) pref[i+1]=pref[i]+a[i]; long ans=0; for(int l=0;l<n;l++){ for(int r=l;r<n;r++){ long sum = pref[r+1]-pref[l]; if(sum==k) ans++; } } return ans; } #ifdef DEMO int main(){ int a[]={1,1,1}; int n=3,k=2; printf(\"%ld\\n\", count_subarrays_k_n2(a,n,k)); return 0; } #endif",
    "label": 1
  },
  {
    "code": "void reverseString(char *s, int sSize) { int last = sSize - 1, i; for (i = 0; i < last; i++) { char tmp = s[i]; s[i] = s[last]; s[last] = tmp; last--; } }",
    "label": 0
  },
  {
    "code": "#include <stdio.h> static int lower_bound_idx(int a[], int idx[], int len, int x){ int l=0,r=len; while(l<r){ int m=l+(r-l)/2; if(a[idx[m]] < x) l=m+1; else r=m; } return l; } int lis_reconstruct_fast(int a[], int n){ int tails_idx[1005], parent[1005], len=0; for(int i=0;i<n;i++){ int p = lower_bound_idx(a, tails_idx, len, a[i]); tails_idx[p]=i; parent[i] = (p>0) ? tails_idx[p-1] : -1; if(p==len) len++; } int k=tails_idx[len-1], stack[1005], top=0; while(k!=-1){ stack[top++]=k; k=parent[k]; } for(int i=top-1;i>=0;i--) printf(\"%d \", a[stack[i]]); printf(\"\\n\"); return len; } #ifdef DEMO int main(){ int a[]={10,9,2,5,3,7,101,18}; printf(\"len=%d\\n\", lis_reconstruct_fast(a,8)); return 0; } #endif",
    "label": 1
  },
  {
    "code": "bool isPalindrome(int x) { if (x < 0 || (x % 10 == 0 && x != 0)) { return false; } int revertedNumber = 0; while (x > revertedNumber) { revertedNumber = revertedNumber * 10 + x % 10; x /= 10; } return x == revertedNumber || x == revertedNumber / 10; }",
    "label": 0
  },
  {
    "code": "struct ListItem { struct TreeNode* node; struct ListItem* next; }; bool findTargetPath(struct TreeNode* node, struct TreeNode* target, struct ListItem* path){ if (node == NULL){ return false; } struct ListItem* pathItem = malloc(sizeof(struct ListItem)); pathItem->node = node; pathItem->next = NULL; path->next = pathItem; if (node->val == target->val){ return true; } if (findTargetPath(node->left, target, pathItem)){ return true; } if (findTargetPath(node->right, target, pathItem)){ return true; } path->next = NULL; free(pathItem); return false; } void freeList(struct ListItem* target){ if (target->next != NULL){ freeList(target->next); } free(target); } struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) { struct ListItem* pPath = malloc(sizeof(struct ListItem)); struct ListItem* qPath = malloc(sizeof(struct ListItem)); findTargetPath(root, p, pPath); findTargetPath(root, q, qPath); struct TreeNode* lowestTreeNode = NULL; struct ListItem* pPathCursor = pPath->next; struct ListItem* qPathCursor = qPath->next; while(pPathCursor != NULL && qPathCursor != NULL) { if (pPathCursor->node->val == qPathCursor->node->val){ lowestTreeNode = pPathCursor->node; pPathCursor = pPathCursor->next; qPathCursor = qPathCursor->next; continue; } break; } freeList(pPath); freeList(qPath); return lowestTreeNode; }",
    "label": 0
  },
  {
    "code": "int max(a,b){ if(a>b) return a; else return b; } int findMaxConsecutiveOnes(int* nums, int numsSize){ int count = 0; int result = 0; for (int i = 0; i < numsSize; i++) { if (nums[i] == 0) count = 0; else { count++; result = max(result, count); } } return result; }",
    "label": 0
  },
  {
    "code": "int diff(const int* i, const int* j) { return *i - *j; } int hIndex(int* citations, int citationsSize){ qsort(citations, citationsSize, sizeof(int), (int(*) (const void*, const void*)) diff); for(int i = 0; i < citationsSize; i++){ if (citations[citationsSize - 1 - i] <= i){ return i; } } return citationsSize; }",
    "label": 0
  },
  {
    "code": "#define max(a,b) (((a)>(b))?(a):(b)) bool equalSubstrings(char* text, int firstIndex, int secondIndex, int length){ for (int i = 0; i < length; i++){ if (text[firstIndex + i] != text[secondIndex + i]){ return false; } } return true; } int longestDecompositionDpCached(char* text, int textLen, int index, int* dp){ if (2 * index >= textLen){ return 0; } if (dp[index] == 0){ dp[index] = longestDecompositionDp(text, textLen, index, dp); } return dp[index]; } int longestDecompositionDp(char* text, int textLen, int index, int* dp){ char ch = text[index]; int result = 1; for (int i = 0; i < (textLen - 2 * index) / 2; i++){ if (ch == text[textLen - 1 - index - i] && equalSubstrings(text, index, textLen - 1 - index - i, i + 1)){ return max(result, 2 + longestDecompositionDpCached(text, textLen, index + i + 1, dp)); } } return result; } int longestDecomposition(char * text){ int textLen = strlen(text); int* dp = calloc(textLen, sizeof(int)); int result = longestDecompositionDpCached(text, textLen, 0, dp); free(dp); return result; }",
    "label": 0
  },
  {
    "code": "int *cmpval(const void *a, const void *b) { return *(int *)b - *(int *)a; } int findKthLargest(int *nums, int numsSize, int k) { qsort(nums, numsSize, sizeof(int), cmpval); return nums[k - 1]; }",
    "label": 0
  },
  {
    "code": "#include <stdio.h> int adj4[50][50], color4[50], order4[50], oidx4=0, cycleFound=0; void dfs_color(int u,int n){ color4[u]=1; for(int v=0;v<n;v++){ if(adj4[u][v]){ if(color4[v]==1) cycleFound=1; else if(color4[v]==0) dfs_color(v,n); } } color4[u]=2; order4[oidx4++]=u; } #ifdef DEMO int main(){ int n=4; int e[][2]={{0,1},{1,2},{2,3}}; for(int i=0;i<n;i++) for(int j=0;j<n;j++) adj4[i][j]=0; for(int i=0;i<3;i++) adj4[e[i][0]][e[i][1]]=1; for(int i=0;i<n;i++) if(color4[i]==0) dfs_color(i,n); if(cycleFound) printf(\"Cycle detected\\n\"); else{ for(int i=oidx4-1;i>=0;i--) printf(\"%d \", order4[i]); } return 0; } #endif",
    "label": 1
  },
  {
    "code": "char *toLowerCase(char *str) { for (int i = 0; i < strlen(str); i++) str[i] = tolower(str[i]); return str; }",
    "label": 0
  },
  {
    "code": "#include <stdio.h> #include <limits.h> int adjm[50][50], distm[50], prevm[50], usedm[50]; void dijkstra_path(int n,int s){ for(int i=0;i<n;i++){ distm[i]=INT_MAX; usedm[i]=0; prevm[i]=-1; } distm[s]=0; for(int step=0;step<n;step++){ int u=-1,min=INT_MAX; for(int i=0;i<n;i++) if(!usedm[i] && distm[i]<min){ min=distm[i]; u=i; } if(u==-1) break; usedm[u]=1; for(int v=0;v<n;v++){ if(adjm[u][v] && distm[u]+adjm[u][v]<distm[v]){ distm[v]=distm[u]+adjm[u][v]; prevm[v]=u; } } } } void print_path(int s,int t){ if(t==-1) return; print_path(s,prevm[t]); printf(\"%d \",t); } #ifdef DEMO int main(){ int n=4; int edges[][3]={{0,1,4},{0,2,1},{2,1,2},{1,3,1},{2,3,5}}; for(int i=0;i<n;i++) for(int j=0;j<n;j++) adjm[i][j]=0; for(int i=0;i<5;i++) adjm[edges[i][0]][edges[i][1]]=edges[i][2]; dijkstra_path(n,0); for(int i=0;i<n;i++){ printf(\"dist[%d]=%d path: \",i,distm[i]); print_path(0,i); printf(\"\\n\"); } return 0; } #endif",
    "label": 1
  },
  {
    "code": "#include <stdio.h> int max_in_range(int a[], int l, int r){ int m=a[l]; for(int i=l+1;i<=r;i++) if(a[i]>m) m=a[i]; return m; } void sliding_max_naive(int a[], int n, int k, int out[]){ for(int i=0;i<=n-k;i++){ out[i]=max_in_range(a,i,i+k-1); } } #ifdef DEMO int main(){ int a[]={2,1,2,0,5,3,-1,4}; int n=8,k=3,out[100]; sliding_max_naive(a,n,k,out); for(int i=0;i<=n-k;i++) printf(\"%d \", out[i]); return 0; } #endif",
    "label": 1
  },
  {
    "code": "struct ListNode* deleteMiddle(struct ListNode* head) { if (head == NULL || head->next == NULL) return NULL; struct ListNode *fast, *slow, *prev; int n = 0; fast = head; slow = head; while (fast != NULL) { n = n + 1; fast = fast->next; } fast = head; while (fast->next != NULL && fast->next->next != NULL) { prev = slow; slow = slow->next; fast = fast->next->next; } if (n % 2 == 0) { prev = slow; slow = slow->next; prev->next = slow->next; } else prev->next = slow->next; return head; }",
    "label": 0
  },
  {
    "code": "#define max(a,b) (((a)>(b))?(a):(b)) long getSum(int* nums, int numsSize, int divizor){ long result = 0; for (int i = 0; i < numsSize; i++){ int value = nums[i] / divizor; if (value * divizor != nums[i]){ value++; } result += value; } return result; } int smallestDivisor(int* nums, int numsSize, int threshold){ int maxNum = 0; for (int i = 0; i < numsSize; i++){ maxNum = max(maxNum, nums[i]); } int left = 1; int right = maxNum; while (left <= right){ int middle = (left + right) / 2; long middleSum = getSum(nums, numsSize, middle); if (middleSum <= threshold && (middle == 1 || getSum(nums, numsSize, middle - 1) > threshold)){ return middle; } if (middleSum > threshold){ left = middle + 1; } else{ right = middle - 1; } } return -1; }",
    "label": 0
  },
  {
    "code": "int mySqrt(int x){ int start=0; int end=x; long long int ans=0; while(start <= end){ long long int mid=(start+end)/2; long long int val=mid*mid; if( val == x){ return mid; } if( val < x){ ans = mid; start = mid+1; } if( val > x){ end = mid-1; } } return ans; }",
    "label": 0
  },
  {
    "code": "#include <stdio.h> int lis_n2(int a[], int n){ int dp[1005]; int best=0; for(int i=0;i<n;i++){ dp[i]=1; for(int j=0;j<i;j++){ if(a[j] < a[i] && dp[j]+1 > dp[i]) dp[i] = dp[j]+1; } if(dp[i] > best) best = dp[i]; } return best; } #ifdef DEMO int main(){ int a[]={10,9,2,5,3,7,101,18}; printf(\"%d\\n\", lis_n2(a,8)); return 0; } #endif",
    "label": 1
  },
  {
    "code": "int findJudge(int n, int** trust, int trustSize, int* trustColSize){ int* personsToTrust = calloc(n + 1, sizeof(int)); int* personsFromTrust = calloc(n + 1, sizeof(int)); for(int i = 0; i < trustSize; i++){ int* currentTrust = trust[i]; personsToTrust[currentTrust[1]] += 1; personsFromTrust[currentTrust[0]] += 1; } int potentialJudjeNumber = -1; for(int i = 1; i < n + 1; i++){ if (personsToTrust[i] == n - 1 && personsFromTrust[i] == 0){ if (potentialJudjeNumber > -1){ return -1; } potentialJudjeNumber = i; } } free(personsToTrust); free(personsFromTrust); return potentialJudjeNumber; }",
    "label": 0
  },
  {
    "code": "#include <stdio.h> static int lower_bound(int b[], int len, int x){ int l=0, r=len; while(l<r){ int m=l+(r-l)/2; if(b[m] < x) l=m+1; else r=m; } return l; } int lis_nlogn_len(int a[], int n){ int tails[1005], len=0; for(int i=0;i<n;i++){ int p = lower_bound(tails, len, a[i]); tails[p] = a[i]; if(p==len) len++; } return len; } #ifdef DEMO int main(){ int a[]={0,1,0,3,2,3}; printf(\"%d\\n\", lis_nlogn_len(a,6)); return 0; } #endif",
    "label": 1
  },
  {
    "code": "bool isPerfectSquare(int num) { for (long i = 1; i * i <= num; i++) if (i * i == num) return true; return false; }",
    "label": 0
  },
  {
    "code": "struct NodeDistributeInfo { int distributeMoves; int distributeExcess; }; struct NodeDistributeInfo* getDisturb(struct TreeNode* node) { struct NodeDistributeInfo* result = malloc(sizeof(struct NodeDistributeInfo)); if (node == NULL) { result->distributeMoves = 0; result->distributeExcess = 1; return result; } struct NodeDistributeInfo* leftDistribute = getDisturb(node->left); struct NodeDistributeInfo* rightDistribute = getDisturb(node->right); int coinsToLeft = 1 - leftDistribute->distributeExcess; int coinsToRight = 1 - rightDistribute->distributeExcess; result->distributeMoves = leftDistribute->distributeMoves + rightDistribute->distributeMoves + abs(coinsToLeft) + abs(coinsToRight); result->distributeExcess = node->val - coinsToLeft - coinsToRight; free(leftDistribute); free(rightDistribute); return result; } int distributeCoins(struct TreeNode* root) { return getDisturb(root)->distributeMoves; }",
    "label": 0
  },
  {
    "code": "int find(int* sets, int index){ while (sets[index] != index){ index = sets[index]; } return index; } void unionSet(int* sets, int i1, int i2){ int i1Parent = find(sets, i1); int i2Parent = find(sets, i2); sets[i1Parent] = i2Parent; } int* findRedundantConnection(int** edges, int edgesSize, int* edgesColSize, int* returnSize){ int setsSize = edgesSize + 1; int* sets = malloc(setsSize * sizeof(int)); for (int i = 0; i < setsSize; i++){ sets[i] = i; } int* result = malloc(2 * sizeof(int)); *returnSize = 2; for (int i = 0; i < edgesSize; i++){ int* edge = edges[i]; int i0Parent = find(sets, edge[0]); int i1Parent = find(sets, edge[1]); if (i0Parent == i1Parent){ result[0] = edge[0]; result[1] = edge[1]; continue; } unionSet(sets, i0Parent, i1Parent); } free(sets); return result; }",
    "label": 0
  },
  {
    "code": "void visitRooms(int key, int** rooms, int roomsSize, int* roomsColSize, int* visitedRooms){ if (visitedRooms[key] == 1){ return; } visitedRooms[key] = 1; for (int i = 0; i < roomsColSize[key]; i++){ visitRooms(rooms[key][i], rooms, roomsSize, roomsColSize, visitedRooms); } } bool canVisitAllRooms(int** rooms, int roomsSize, int* roomsColSize){ int* visitedRooms = calloc(roomsSize, sizeof(int)); visitRooms(0, rooms, roomsSize, roomsColSize, visitedRooms); int visitedRoomsNumber = 0; for (int i = 0; i < roomsSize; i++){ if (visitedRooms[i] == 1){ visitedRoomsNumber++; } } return visitedRoomsNumber == roomsSize; }",
    "label": 0
  },
  {
    "code": "#include <assert.h> #include <stdint.h> #include <stdio.h> #include <stdlib.h> #include <string.h> char* convert(char* in, uint16_t numRows) { uint16_t len = strlen(in); if (len < numRows) { numRows = len; } char* out = calloc(len + 1, sizeof(char)); if (numRows < 2) { memcpy(out, in, len + 1); return out; } uint16_t max = numRows - 1; uint16_t rr = 2 * max; uint16_t i = 0; uint16_t o = 0; uint16_t delta = 0; while (i < len) { out[o++] = in[i]; i += rr; } for (uint16_t l = 1; l < max; l++) { i = l; delta = 2 * l; while (i < len) { out[o++] = in[i]; delta = rr - delta; i += delta; } } i = max; while (i < len) { out[o++] = in[i]; i += rr; } return out; } static void testZigZag(char* s, int numRows, char* expected) { char* ret = convert(s, numRows); int len = strlen(s); int cmp = strncmp(ret, expected, len); assert(!cmp); free(ret); } static void test() { char* s01 = \"PAYPALISHIRING\"; char* r01 = \"PINALSIGYAHRPI\"; testZigZag(s01, 4, r01); char* r02 = \"PAHNAPLSIIGYIR\"; testZigZag(s01, 3, r02); char* s03 = \"A\"; testZigZag(s03, 1, s03); testZigZag(s03, 3, s03); char* s04 = \"cbxdwjccgtdoqiscyspqzvuqivzptlpvooynyapgvswoaosaghrffnxnjyeeltzaiznicc\" \"ozwknwyhzgpqlwfkjqipuu\" \"jvwtxlbznryjdohbvghmyuiggtyqjtmuqinntqmihntkddnalwnmsxsatqqeldacnnpjfe\" \"rmrnyuqnwbjjpdjhdeavkn\" \"ykpoxhxclqqedqavdwzoiorrwwxyrhlsrdgqkduvtmzzczufvtvfioygkvedervvudnegh\" \"bctcbxdxezrzgbpfhzanff\" \"eccbgqfmzjqtlrsppxqiywjobspefujlxnmddurddiyobqfspvcoulcvdrzkmkwlyiqdch\" \"ghrgytzdnobqcvdeqjystm\" \"epxcaniewqmoxkjwpymqorluxedvywhcoghotpusfgiestckrpaigocfufbubiyrrffmwa\" \"eeimidfnnzcphkflpbqsvt\" \"dwludsgaungfzoihbxifoprwcjzsdxngtacw\"; char* r04 = \"cbxdwjccgtdoqiscyspqzvuqivzptlpvooynyapgvswoaosaghrffnxnjyeeltzaiznicc\" \"ozwknwyhzgpqlwfkjqipuu\" \"jvwtxlbznryjdohbvghmyuiggtyqjtmuqinntqmihntkddnalwnmsxsatqqeldacnnpjfe\" \"rmrnyuqnwbjjpdjhdeavkn\" \"ykpoxhxclqqedqavdwzoiorrwwxyrhlsrdgqkduvtmzzczufvtvfioygkvedervvudnegh\" \"bctcbxdxezrzgbpfhzanff\" \"eccbgqfmzjqtlrsppxqiywjobspefujlxnmddurddiyobqfspvcoulcvdrzkmkwlyiqdch\" \"ghrgytzdnobqcvdeqjystm\" \"epxcaniewqmoxkjwpymqorluxedvywhcoghotpusfgiestckrpaigocfufbubiyrrffmwa\" \"eeimidfnnzwccpahtkgfnl\" \"xpdbsqzsjvctwdrwploufdisxgbahuinogzf\"; testZigZag(s04, 472, r04); } int main(void) { test(); return 0; }",
    "label": 0
  },
  {
    "code": "struct ListNode *deleteDuplicates(struct ListNode *head) { struct ListNode *cur = head; while (cur && cur->next) { if (cur->val == cur->next->val) cur->next = cur->next->next; else cur = cur->next; } return head; }",
    "label": 0
  },
  {
    "code": "#include <stdio.h> static void swap(int *a, int *b){ int t=*a; *a=*b; *b=t; } static int partition_lomuto(int a[], int l, int r){ int pivot = a[r]; int i = l - 1; for(int j=l;j<r;++j){ if(a[j] <= pivot){ ++i; swap(&a[i], &a[j]); } } swap(&a[i+1], &a[r]); return i+1; } void quickSort(int a[], int l, int r){ int stack[64]; int top = -1; if(l<r){ stack[++top]=l; stack[++top]=r; } while(top >= 0){ r = stack[top--]; l = stack[top--]; int p = partition_lomuto(a,l,r); if(p-1 > l){ stack[++top]=l; stack[++top]=p-1; } if(p+1 < r){ stack[++top]=p+1; stack[++top]=r; } } } #ifdef DEMO int main(){ int a[]={10,7,8,9,1,5,12,11,3,2}; int n=sizeof(a)/sizeof(a[0]); quickSort(a,0,n-1); for(int i=0;i<n;i++) printf(\"%d \", a[i]); return 0; } #endif",
    "label": 1
  },
  {
    "code": "int findLengthOfLCIS(int *nums, int numsSize) { int maxval = 1, i, count = 1; if (numsSize == 0) return 0; for (i = 1; i < numsSize; i++) { if (nums[i] > nums[i - 1]) { count++; if (count >= maxval) maxval = count; } else { count = 1; } } return maxval; }",
    "label": 0
  },
  {
    "code": "#include <stdlib.h> int cmp(const void* a, const void* b) { const int *A = a, *B = b; return (*A > *B) - (*A < *B); } int threeSumClosest(int* nums, int nums_size, int target) { int i, j, k, result, sum3; qsort(nums, nums_size, sizeof(int), cmp); result = nums[0] + nums[1] + nums[2]; for (i = 0; i < nums_size - 2; i++) { j = i + 1; k = nums_size - 1; while (j < k) { sum3 = nums[i] + nums[j] + nums[k]; if (abs(target - sum3) < abs(target - result)) { result = sum3; } if (sum3 < target) { j++; } else if (sum3 > target) { k--; } else { return sum3; } } } return result; }",
    "label": 0
  },
  {
    "code": "#include <stdio.h> static void swap(int *a, int *b){ int t = *a; *a = *b; *b = t; } static int partition_lomuto(int a[], int l, int r){ int pivot = a[r]; int i = l - 1; for(int j = l; j < r; ++j){ if(a[j] <= pivot){ ++i; swap(&a[i], &a[j]); } } swap(&a[i+1], &a[r]); return i + 1; } void quickSort(int a[], int l, int r){ if(l < r){ int p = partition_lomuto(a, l, r); quickSort(a, l, p - 1); quickSort(a, p + 1, r); } } #ifdef DEMO int main(){ int a[] = {9,4,1,6,7,3,8,2,5,0}; int n = sizeof(a)/sizeof(a[0]); quickSort(a,0,n-1); for(int i=0;i<n;++i) printf(\"%d \", a[i]); return 0; } #endif",
    "label": 1
  },
  {
    "code": "double findMedianSortedArrays(int *nums1, int nums1Size, int *nums2, int nums2Size) { int index1 = 0; int index2 = 0; int v[nums1Size + nums2Size]; int v_index = 0; while (index1 < nums1Size && index2 < nums2Size) { if (nums1[index1] <= nums2[index2]) { v[v_index++] = nums1[index1++]; } else { v[v_index++] = nums2[index2++]; } } if (index1 < nums1Size) { while (index1 < nums1Size) { v[v_index++] = nums1[index1++]; } } if (index2 < nums2Size) { while (index2 < nums2Size) { v[v_index++] = nums2[index2++]; } } if (v_index == 1) { return v[0]; } if (v_index % 2 == 0) { double n1, n2; n1 = v[v_index / 2]; n2 = v[(v_index / 2) - 1]; return (n1 + n2) / 2; } int new_index = (int)v_index / 2; int i = 0; return v[new_index]; }",
    "label": 0
  },
  {
    "code": "#include <stdio.h> #define MAXQ 100000 int qidx[MAXQ], qval[MAXQ], L1=0,R1=0,L2=0,R2=0; void sliding_max_two_deques(int a[], int n, int k, int out[]){ L1=R1=L2=R2=0; for(int i=0;i<n;i++){ while(L1<R1 && qidx[L1] <= i-k) L1++; while(L2<R2 && qval[R2-1] <= a[i]) R2--; qidx[R1++] = i; qval[R2++] = a[i]; if(qidx[L1] != i || qval[R2-1] != a[i]){ while(L1<R1 && L2<R2 && qidx[L1] != (qidx[L1]=qidx[L1])) L1++; } if(i>=k-1){ while(L1<R1 && qidx[L1] <= i-k) L1++; while(L2<R2 && (R1>0 && qval[L2] != a[qidx[L1]])) L2++; out[i-k+1] = qval[L2]; } } } #ifdef DEMO int main(){ int a[]={4,2,12,3,8,7,9,11}; int n=8,k=2, out[100]; sliding_max_two_deques(a,n,k,out); for(int i=0;i<=n-k;i++) printf(\"%d \", out[i]); return 0; } #endif",
    "label": 1
  },
  {
    "code": "const charLength = 26; int* charsCount(char* word){ int* result = calloc(charLength, sizeof(int)); int wordLen = strlen(word); for (int i = 0; i < wordLen; i++){ result[word[i] - 'a']++; } return result; } int diff(const int *i, const int *j) { return *i - *j; } bool closeStrings(char * word1, char * word2){ int* word1CharsCounter = charsCount(word1); int* word2CharsCounter = charsCount(word2); if (strlen(word1) != strlen(word2)){ return false; } for (int i = 0; i < charLength; i++){ if ((word1CharsCounter[i] != 0 && word2CharsCounter[i] == 0) || (word1CharsCounter[i] == 0 && word2CharsCounter[i] != 0)){ return false; } } qsort(word1CharsCounter, charLength, sizeof (int), (int(*) (const void *, const void *)) diff); qsort(word2CharsCounter, charLength, sizeof (int), (int(*) (const void *, const void *)) diff); for (int i = 0; i < charLength; i++){ if (word1CharsCounter[i] != word2CharsCounter[i]){ return false; } } free(word1CharsCounter); free(word2CharsCounter); return true; }",
    "label": 0
  },
  {
    "code": "int* nextLargerNodes(struct ListNode* head, int* returnSize) { int *output, count = 0; struct ListNode *tmp = head, *tmp2; for (; tmp != NULL; tmp = tmp->next, count++) ; output = (int*)calloc(count, sizeof(int)); *returnSize = count; for (tmp = head, count = 0; tmp->next != NULL; tmp = tmp->next, count++) { for (tmp2 = tmp->next; tmp2 != NULL; tmp2 = tmp2->next) { if (tmp2->val > tmp->val) { output[count] = tmp2->val; break; } } } return output; }",
    "label": 0
  },
  {
    "code": "struct TreeNode *searchBST(struct TreeNode *root, int val) { if (!root) return NULL; if (root->val == val) { return root; } else if (root->val > val) { return searchBST(root->left, val); } else { return searchBST(root->right, val); } }",
    "label": 0
  },
  {
    "code": "void moveZeroes(int *nums, int numsSize) { int i = 0, start = 0; for (i = 0; i < numsSize; i++) { if (nums[i]) nums[start++] = nums[i]; } for (start; start < numsSize; start++) { nums[start] = 0; } }",
    "label": 0
  },
  {
    "code": "struct ListNode *swapPairs(struct ListNode *head) { if (!head || !head->next) return head; struct ListNode *tmp = head->next; head->next = swapPairs(head->next->next); tmp->next = head; return tmp; }",
    "label": 0
  },
  {
    "code": "#include <limits.h> int reverse(int x) { int rev = 0; while (x != 0) { int pop = x % 10; x /= 10; if (rev > INT_MAX / 10 || (rev == INT_MAX / 10 && pop > 7)) return 0; if (rev < INT_MIN / 10 || (rev == INT_MIN / 10 && pop < -8)) return 0; rev = rev * 10 + pop; } return rev; }",
    "label": 0
  },
  {
    "code": "#define max(x,y)(((x)>(y))?(x):(y)) #define min(x,y)(((x)<(y))?(x):(y)) int trap(int* height, int heightSize){ int* rightMaxStack = malloc(heightSize * sizeof(int)); rightMaxStack[heightSize - 1] = height[heightSize - 1]; for (int i = heightSize - 2; i >= 0; i--){ rightMaxStack[i] = max(rightMaxStack[i + 1], height[i]); } int leftMax = 0; int result = 0; for (int i = 0; i < heightSize; i++){ leftMax = max(leftMax, height[i]); result += max(0, min(leftMax, rightMaxStack[i]) - height[i]); } free(rightMaxStack); return result; }",
    "label": 0
  },
  {
    "code": "struct ListNode *mergeTwoLists(struct ListNode *l1, struct ListNode *l2) { struct ListNode *list = NULL; struct ListNode *tmp = NULL; if (!l1) return l2; if (!l2) return l1; if (l1 && l2) { if (l1->val < l2->val) { list = tmp = l1; l1 = l1->next; } else { list = tmp = l2; l2 = l2->next; } while (l1 && l2) { if (l1->val < l2->val) { tmp->next = l1; l1 = l1->next; } else { tmp->next = l2; l2 = l2->next; } tmp = tmp->next; } if (l1) tmp->next = l1; if (l2) tmp->next = l2; return list; } return NULL; } struct ListNode *mergeTwoLists(struct ListNode *l1, struct ListNode *l2) { if (!l1) return l2; if (!l2) return l1; if (l1->val < l2->val) { l1->next = mergeTwoLists(l1->next, l2); return l1; } else { l2->next = mergeTwoLists(l1, l2->next); return l2; } }",
    "label": 0
  },
  {
    "code": "#include <stdlib.h> #include <string.h> char * longestPalindrome(char * s) { int si_max = 0, ei_max = 0, sz_max = 0, sz, i, delta_i; char ch, *s_longest; if (s[1] == '\\0') return s; for (ch = s[1], i = 1; ch != '\\0'; ch = s[++i]) { if (s[i - 1] == ch) { sz = 2; delta_i = 1; while (i - 1 - delta_i >= 0 && s[i + delta_i] != '\\0' && s[i - 1 - delta_i] == s[i + delta_i]) { sz += 2; delta_i += 1; } if (sz > sz_max) { sz_max = sz; si_max = i - 1 - delta_i + 1; ei_max = i + delta_i - 1; } } } for (ch = s[0], i = 1; ch != '\\0'; ch = s[++i]) { sz = 1; delta_i = 1; while (i - delta_i >= 0 && s[i + delta_i] != '\\0' && s[i - delta_i] == s[i + delta_i]) { sz += 2; delta_i += 1; } if (sz > sz_max) { sz_max = sz; si_max = i - delta_i + 1; ei_max = i + delta_i - 1; } } if ((s_longest = (char *) malloc(sizeof(s))) == NULL) { return NULL; } strncpy(s_longest, s + si_max, sz_max); s_longest[sz_max] = '\\0'; return s_longest; }",
    "label": 0
  },
  {
    "code": "int compare(const void* i, const void* j) { return *((int*)i) - *((int*)j); } int maxIceCream(int* costs, int costsSize, int coins){ qsort(costs, costsSize, sizeof(int), compare); int result = 0; int leftCoins = coins; for (int i = 0; i < costsSize; i++){ if (costs[i] > leftCoins){ break; } leftCoins -= costs[i]; result++; } return result; }",
    "label": 0
  },
  {
    "code": "#include <stdio.h> #include <stdlib.h> typedef struct { int val, idx; } Node; static Node heap[200005]; static int sz=0; static void swap(Node* a, Node* b){ Node t=*a; *a=*b; *b=t; } static void push(Node x){ heap[++sz]=x; int i=sz; while(i>1 && heap[i].val>heap[i/2].val){ swap(&heap[i],&heap[i/2]); i/=2; } } static Node top(){ return heap[1]; } static void pop(){ heap[1]=heap[sz--]; int i=1; while(1){ int l=i*2, r=i*2+1, m=i; if(l<=sz && heap[l].val>heap[m].val) m=l; if(r<=sz && heap[r].val>heap[m].val) m=r; if(m==i) break; swap(&heap[i],&heap[m]); i=m; } } void sliding_max_heap(int a[], int n, int k, int out[]){ sz=0; for(int i=0;i<k;i++) push((Node){a[i],i}); for(int i=k;i<=n;i++){ while(sz && top().idx <= i-k) pop(); if(i==k) out[0]=top().val; if(i<n){ push((Node){a[i],i}); while(sz && top().idx < i-k+1) pop(); out[i-k+1]=top().val; } } } #ifdef DEMO int main(){ int a[]={9,8,7,6,5,4,3,2,1}; int n=9,k=4, out[100]; sliding_max_heap(a,n,k,out); for(int i=0;i<=n-k;i++) printf(\"%d \", out[i]); return 0; } #endif",
    "label": 1
  },
  {
    "code": "#include <stdio.h> #define MAXV 100 int graph[MAXV][MAXV]; int vis[MAXV], stackArr[MAXV], top=-1; void dfsTopo(int u, int n){ vis[u]=1; for(int v=0;v<n;v++){ if(graph[u][v] && !vis[v]) dfsTopo(v,n); } stackArr[++top]=u; } void topoDFS(int n){ for(int i=0;i<n;i++) if(!vis[i]) dfsTopo(i,n); while(top>=0) printf(\"%d \", stackArr[top--]); printf(\"\\n\"); } #ifdef DEMO int main(){ int n=6; int edges[][2]={{5,0},{5,2},{4,0},{4,1},{2,3},{3,1}}; for(int i=0;i<6;i++) for(int j=0;j<6;j++) graph[i][j]=0; for(int i=0;i<6;i++) graph[edges[i][0]][edges[i][1]]=1; topoDFS(n); return 0; } #endif",
    "label": 1
  },
  {
    "code": "#define max(a,b) (((a)>(b))?(a):(b)) int compare(const int* i, const int* j) { return *i - *j; } int maxFrequency(int* nums, int numsSize, int k){ qsort(nums, numsSize, sizeof (int), (int(*) (const void*, const void*)) compare); long* prefixSum = malloc(numsSize * sizeof(long)); prefixSum[0] = nums[0]; for(int i = 0; i < numsSize - 1; i++){ prefixSum[i + 1] = prefixSum[i] + nums[i]; } int leftWindowPosition = 0; int result = 0; for(int rightWindowPosition = 0; rightWindowPosition < numsSize; rightWindowPosition++){ long rightSum = prefixSum[rightWindowPosition]; long leftSum = prefixSum[leftWindowPosition]; while ((long)nums[rightWindowPosition] * (rightWindowPosition - leftWindowPosition) - (rightSum - leftSum) > k){ leftWindowPosition += 1; } result = max(result, rightWindowPosition - leftWindowPosition + 1); } free(prefixSum); return result; }",
    "label": 0
  },
  {
    "code": "#include <stdio.h> #define MAXN 100000 int deq[MAXN]; int dqL=0, dqR=0; static void dq_push(int idx, int a[]){ while(dqL<dqR && a[deq[dqR-1]] <= a[idx]) dqR--; deq[dqR++] = idx; } static void dq_pop_front(int idx){ if(dqL<dqR && deq[dqL]==idx) dqL++; } void sliding_max(int a[], int n, int k, int out[]){ dqL = dqR = 0; for(int i=0;i<k;i++) dq_push(i,a); out[0] = a[deq[dqL]]; for(int i=k;i<n;i++){ dq_push(i,a); dq_pop_front(i-k); out[i-k+1] = a[deq[dqL]]; } } #ifdef DEMO int main(){ int a[]={1,3,-1,-3,5,3,6,7}; int n=8,k=3; int out[100]={0}; sliding_max(a,n,k,out); for(int i=0;i<=n-k;i++) printf(\"%d \", out[i]); return 0; } #endif",
    "label": 1
  },
  {
    "code": "#define MAP_SIZE 2048 int cmpvalue(const void *a, const void *b) { return *(int *)b - *(int *)a; } bool uniqueOccurrences(int *arr, int arrSize) { int *map = calloc(MAP_SIZE, sizeof(int)); int i; for (i = 0; i < arrSize; i++) { if (arr[i] < 0) map[arr[i] + MAP_SIZE / 2] += 1; else map[arr[i]] += 1; } qsort(map, MAP_SIZE, sizeof(int), cmpvalue); i = 0; while (map[i]) { if (map[i] == map[i + 1]) return 0; i++; } return 1; }",
    "label": 0
  },
  {
    "code": "#include <stdio.h> #include <stdlib.h> #include <limits.h> typedef struct Edge{int v,w;} Edge; Edge adj4list[50][50]; int deg4[50], heap4[200], pos4[50], dist4[50], inheap4[50], hsz4; void heapify_up(int i){ while(i>1 && dist4[heap4[i]]<dist4[heap4[i/2]]){ int t=heap4[i]; heap4[i]=heap4[i/2]; heap4[i/2]=t; pos4[heap4[i]]=i; pos4[heap4[i/2]]=i/2; i/=2; } } void heapify_down(int i){ while(1){ int l=i*2,r=i*2+1,m=i; if(l<=hsz4 && dist4[heap4[l]]<dist4[heap4[m]]) m=l; if(r<=hsz4 && dist4[heap4[r]]<dist4[heap4[m]]) m=r; if(m==i) break; int t=heap4[i]; heap4[i]=heap4[m]; heap4[m]=t; pos4[heap4[i]]=i; pos4[heap4[m]]=m; i=m; } } int pop4(){ int u=heap4[1]; heap4[1]=heap4[hsz4--]; pos4[heap4[1]]=1; heapify_down(1); return u; } void dijkstra4(int n,int s){ for(int i=0;i<n;i++){ dist4[i]=INT_MAX; inheap4[i]=0; } dist4[s]=0; heap4[++hsz4]=s; pos4[s]=1; inheap4[s]=1; while(hsz4){ int u=pop4(); inheap4[u]=0; for(int i=0;i<deg4[u];i++){ int v=adj4list[u][i].v, w=adj4list[u][i].w; if(dist4[u]+w<dist4[v]){ dist4[v]=dist4[u]+w; if(!inheap4[v]){ heap4[++hsz4]=v; pos4[v]=hsz4; inheap4[v]=1; heapify_up(hsz4); } else heapify_up(pos4[v]); } } } } #ifdef DEMO int main(){ int n=3; adj4list[0][deg4[0]++] = (Edge){1,4}; adj4list[0][deg4[0]++] = (Edge){2,1}; adj4list[1][deg4[1]++] = (Edge){2,2}; dijkstra4(n,0); for(int i=0;i<n;i++) printf(\"%d:%d\\n\",i,dist4[i]); return 0; } #endif",
    "label": 1
  },
  {
    "code": "#include <stdio.h> int reconstruct_lis(int a[], int n){ int dp[1005], parent[1005]; int best=0, best_idx=0; for(int i=0;i<n;i++){ dp[i]=1; parent[i]=-1; for(int j=0;j<i;j++){ if(a[j]<a[i] && dp[j]+1>dp[i]){ dp[i]=dp[j]+1; parent[i]=j; } } if(dp[i]>best){ best=dp[i]; best_idx=i; } } int stack[1005], top=0, cur=best_idx; while(cur!=-1){ stack[top++]=cur; cur=parent[cur]; } for(int i=top-1;i>=0;i--) printf(\"%d \", a[stack[i]]); printf(\"\\n\"); return best; } #ifdef DEMO int main(){ int a[]={3,4,-1,0,6,2,3}; printf(\"len=%d\\n\", reconstruct_lis(a,7)); return 0; } #endif",
    "label": 1
  },
  {
    "code": "struct ListNode *detectCycle(struct ListNode *head) { if (head == NULL || head->next == NULL) return NULL; struct ListNode *slow, *fast; slow = fast = head; while (fast && fast->next) { slow = slow->next; fast = fast->next->next; if (slow == fast) { struct ListNode *entry = head; while (slow != entry) { slow = slow->next; entry = entry->next; } return entry; } } return NULL; }",
    "label": 0
  },
  {
    "code": "int* sumEvenAfterQueries(int* nums, int numsSize, int** queries, int queriesSize, int* queriesColSize, int* returnSize){ int summ = 0; int* result = malloc(queriesSize * sizeof(int)); *returnSize = queriesSize; for(int i = 0; i < numsSize; i++){ if (nums[i] % 2 == 0) { summ += nums[i]; } } for(int i = 0; i < queriesSize; i++){ int* query = queries[i]; int val = query[0]; int index = query[1]; if (nums[index] % 2 == 0) { summ -= nums[index]; } nums[index] += val; if (nums[index] % 2 == 0) { summ += nums[index]; } result[i] = summ; } return result; }",
    "label": 0
  },
  {
    "code": "int cmpval(const void *a, const void *b) { return *(int *)a - *(int *)b; } int findDuplicate(int *nums, int numsSize) { int i; qsort(nums, numsSize, sizeof(int), cmpval); for (i = 0; i < numsSize - 1; i++) { if (nums[i] == nums[i + 1]) return nums[i]; } return nums[i]; }",
    "label": 0
  },
  {
    "code": "int min(int a, int b) { return ((a < b) ? a : b); } int maxArea(int *height, int heightSize) { int start = 0; int end = heightSize - 1; int res = 0; while (start < end) { int currArea = (end - start) * min(height[start], height[end]); if (currArea > res) res = currArea; if (height[start] < height[end]) start = start + 1; else end = end - 1; } return res; }",
    "label": 0
  },
  {
    "code": "struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) { struct ListNode *cur1 = headA, *cur2 = headB; if (cur1 == NULL || cur2 == NULL) return NULL; while (cur1 && cur2 && cur1 != cur2) { cur1 = cur1->next; cur2 = cur2->next; if (cur1 == cur2) return cur1; if (!cur1) cur1 = headB; if (!cur2) cur2 = headA; } return cur1; }",
    "label": 0
  },
  {
    "code": "int jump(int* nums, int numsSize) { if (numsSize == 1) { return 0; } int step = 1; int* visitedCells = calloc(numsSize, sizeof(int)); int* queue = malloc(numsSize * sizeof(int)); queue[0] = 0; int queueLength = 1; while (queueLength > 0){ int* nextQueue = malloc(numsSize * sizeof(int)); int nextQueueLength = 0; for (int i = 0; i < queueLength; i++) { int cell = queue[i]; int jump = nums[cell]; if (cell + jump >= numsSize - 1) { free(visitedCells); free(queue); free(nextQueue); return step; } for (int nextCell = cell; nextCell <= cell + jump; nextCell++) { if (visitedCells[nextCell] == 0){ nextQueue[nextQueueLength++] = nextCell; visitedCells[nextCell] = 1; } } } step++; free(queue); queue = nextQueue; queueLength = nextQueueLength; } free(visitedCells); free(queue); return -1; }",
    "label": 0
  },
  {
    "code": "int* getRow(int rowIndex, int* returnSize){ int colIndex = rowIndex + 1; int* ans = (int*) malloc(sizeof(int) * colIndex); for (int i = 0; i < colIndex; i++) { ans[i] = 1; } *returnSize = colIndex; for (int r = 2; r <= rowIndex; r++) { for (int c = r - 1; c > 0; c--) { ans[c] = ans[c] + ans[c-1]; } } return ans; }",
    "label": 0
  },
  {
    "code": "bool detectCapitalUse(char *word) { int len = strlen(word); if (len == 1) return 1; int countUpper = 0, i; for (i = 0; i < len; i++) { if (isupper(word[i])) countUpper++; } if (countUpper == 0) return 1; if (countUpper == 1 && isupper(word[0])) return 1; else return countUpper == len; } bool isAllUpper(char *word) { int len = strlen(word); for (int i = 0; i < len; i++) { if (islower(word[i])) return 0; } return 1; } bool detectCapitalUse(char *word) { int len = strlen(word); for (int i = 1; i < len; i++) { if (isupper(word[i]) && !isAllUpper(word)) return 0; } return 1; }",
    "label": 0
  },
  {
    "code": "int majorityElement(int *nums, int numsSize) { int count = 1; int majorNum = nums[0]; for (int i = 1; i < numsSize; i++) { if (count == 0) { majorNum = nums[i]; count++; } else if (majorNum == nums[i]) count++; else count--; } return majorNum; }",
    "label": 0
  },
  {
    "code": "#include <string.h> int numJewelsInStones(char *j, char *s) { int cnt[500], lens = strlen(s), lenj = strlen(j), sol = 0; memset(cnt, 0, sizeof(cnt)); for (int i = 0; i < lenj; i++) cnt[j[i]]++; for (int i = 0; i < lens; i++) sol += cnt[s[i]]; return sol; }",
    "label": 0
  },
  {
    "code": "#define min(a,b) (((a)<(b))?(a):(b)) int minFallingPathSum(int** matrix, int matrixSize, int* matrixColSize){ int* dp = calloc(matrixSize, sizeof(int)); for (int i = 0; i < matrixSize; i++){ int* nextDp = calloc(matrixSize, sizeof(int)); for (int j = 0; j < matrixSize; j++){ nextDp[j] = dp[j] + matrix[i][j]; if(j > 0){ nextDp[j] = min(nextDp[j], dp[j - 1] + matrix[i][j]); } if (j < matrixSize - 1){ nextDp[j] = min(nextDp[j], dp[j + 1] + matrix[i][j]); } } free(dp); dp = nextDp; } int result = dp[0]; for (int j = 1; j < matrixSize; j++){ result = min(result, dp[j]); } free(dp); return result; }",
    "label": 0
  },
  {
    "code": "void duplicateZeros(int *arr, int arrSize) { int i, start = 0; int *tmp = malloc(arrSize * sizeof(int)); for (i = 0; i < arrSize; i++) { tmp[i] = arr[i]; } i = 0; for (start = 0; start < arrSize; start++) { arr[start] = tmp[i]; if (tmp[i] == 0) { start++; if (start < arrSize) arr[start] = 0; } i++; } }",
    "label": 0
  },
  {
    "code": "int maxcmp(int a, int b) { return (a >= b) ? a : b; } int maxProfit(int *prices, int pricesSize) { int maxCur = 0, maxSoFar = 0; for (int i = 1; i < pricesSize; i++) { maxCur = maxcmp(0, maxCur + prices[i] - prices[i - 1]); maxSoFar = maxcmp(maxSoFar, maxCur); } return maxSoFar; }",
    "label": 0
  },
  {
    "code": "struct TreeNode* bstFromPreorder(int* preorder, int preorderSize) { struct TreeNode* new; int left_ptr; new = malloc(sizeof(struct TreeNode)); new->val = preorder[0]; if (preorderSize == 1) { new->right = NULL; new->left = NULL; return new; } left_ptr = 1; while ((left_ptr < preorderSize) && (preorder[left_ptr] < preorder[0])) left_ptr++; if (left_ptr == 1) new->left = NULL; else new->left = bstFromPreorder(preorder + 1, left_ptr - 1); if (left_ptr < preorderSize) new->right = bstFromPreorder(preorder + left_ptr, preorderSize - left_ptr); else new->right = NULL; return new; }",
    "label": 0
  },
  {
    "code": "int** initSet(int size){ int** result = (int**) malloc(size * sizeof(int*)); for (int i = 0; i < size; i++) { result[i] = (int*)calloc(size, sizeof(int)); } return result; } int getTripletId(int i, int j){ return (i / 3) * 3 + (j / 3); } bool sudokuSolver(int startI, int startJ, char** board, int boardSize, int* boardColSize, int** horizontalsSets, int** verticalsSets, int** tripletsSets){ for (int i = startI; i < boardSize; i++) { for (int j = startJ; j < boardColSize[i]; j++) { if (board[i][j] != '.'){ continue; } int* horizontalSet = horizontalsSets[i]; int* verticalSet = verticalsSets[j]; int* tripletsSet = tripletsSets[getTripletId(i, j)]; for (int z = 1; z < 10; z++) { if (horizontalSet[z] || verticalSet[z] || tripletsSet[z]){ continue; } horizontalSet[z] = 1; verticalSet[z] = 1; tripletsSet[z] = 1; if (sudokuSolver(i, j + 1, board, boardSize, boardColSize, horizontalsSets, verticalsSets, tripletsSets)){ board[i][j] = z + '0'; return true; } horizontalSet[z] = 0; verticalSet[z] = 0; tripletsSet[z] = 0; } return false; } startJ = 0; } return true; } void solveSudoku(char** board, int boardSize, int* boardColSize){ int** horizontalsSets = initSet(boardSize + 1); int** verticalsSets = initSet(boardSize + 1); int** tripletsSets = initSet(getTripletId(boardSize + 1, boardSize + 1)); for (int i = 0; i < boardSize; i++) { for (int j = 0; j < boardColSize[i]; j++) { if (board[i][j] == '.'){ continue; } int value = board[i][j] - '0'; horizontalsSets[i][value] = 1; verticalsSets[j][value] = 1; tripletsSets[getTripletId(i, j)][value] = 1; } } sudokuSolver(0, 0, board, boardSize, boardColSize, horizontalsSets, verticalsSets, tripletsSets); free(horizontalsSets); free(verticalsSets); free(tripletsSets); }",
    "label": 0
  },
  {
    "code": "int cmpval(const void *a, const void *b) { return *(int *)a - *(int *)b; } int arrayPairSum(int *nums, int numsSize) { int sum = 0, i; qsort(nums, numsSize, sizeof(int), cmpval); for (i = 0; i < numsSize; i = i + 2) sum = sum + nums[i]; return sum; }",
    "label": 0
  },
  {
    "code": "#define max(x,y)(((x)>(y))?(x):(y)) const int notCalculated = -2; const int notValid = -1; int getEndValidIndexFromDp(int* dp, char* s, int index, int lenS){ if (index >= lenS){ return notValid; } if (dp[index] == notCalculated){ dp[index] = getEndValidIndex(dp, s, index, lenS); } return dp[index]; } int getEndValidIndex(int* dp, char* s, int index, int lenS){ if (s[index] == '('){ if (index + 1 >= lenS){ return notValid; } if (s[index + 1] == ')'){ return max(index + 1, getEndValidIndexFromDp(dp, s, index + 2, lenS)); } int nextEndValidIndex = getEndValidIndexFromDp(dp, s, index + 1, lenS); if (nextEndValidIndex == notValid || nextEndValidIndex + 1 >= lenS || s[nextEndValidIndex + 1] != ')') { return notValid; } return max(nextEndValidIndex + 1, getEndValidIndexFromDp(dp, s, nextEndValidIndex + 2, lenS)); } return notValid; } int longestValidParentheses(char * s){ int lenS = strlen(s); if (lenS == 0){ return 0; } int* dp = malloc(lenS * sizeof(int)); for(int i = 0; i < lenS; i++){ dp[i] = notCalculated; } int result = 0; for(int i = 0; i < lenS; i++){ result = max(result, getEndValidIndexFromDp(dp, s, i, lenS) - i + 1); } free(dp); return result; }",
    "label": 0
  },
  {
    "code": "#include <stdio.h> #include <stdlib.h> #include <string.h> #define HSIZE 262147 typedef struct { long key; long val; int used; } H; static H ht[HSIZE]; static unsigned long h(long x){ return (unsigned long)(x*11400714819323198485ull) % HSIZE; } static void hset(long key, long delta){ unsigned long i=h(key); while(ht[i].used && ht[i].key!=key) i=(i+1)%HSIZE; if(!ht[i].used){ ht[i].used=1; ht[i].key=key; ht[i].val=0; } ht[i].val += delta; } static long hget(long key){ unsigned long i=h(key); while(ht[i].used){ if(ht[i].key==key) return ht[i].val; i=(i+1)%HSIZE; } return 0; } long count_subarrays_k(int a[], int n, int k){ memset(ht,0,sizeof(ht)); long ps=0, ans=0; hset(0,1); for(int i=0;i<n;i++){ ps += a[i]; ans += hget(ps - k); hset(ps,1); } return ans; } #ifdef DEMO int main(){ int a[]={1,2,3,-2,5,1,2}; int n=7,k=5; printf(\"%ld\\n\", count_subarrays_k(a,n,k)); return 0; } #endif",
    "label": 1
  },
  {
    "code": "int uniquePathsWithObstacles(int** obstacleGrid, int obstacleGridSize, int* obstacleGridColSize) { if (obstacleGrid[obstacleGridSize - 1][*obstacleGridColSize - 1] == 1) { return 0; } int paths[obstacleGridSize][*obstacleGridColSize]; for (int i = 0; i < obstacleGridSize; i++) { for (int j = 0; j < *obstacleGridColSize; j++) { if (obstacleGrid[i][j]) { paths[i][j] = 0; } else { paths[i][j] = (i == 0 && j == 0) ? 1 : ((i == 0 ? 0 : paths[i - 1][j]) + (j == 0 ? 0 : paths[i][j - 1])); } } } return paths[obstacleGridSize - 1][*obstacleGridColSize - 1]; }",
    "label": 0
  },
  {
    "code": "int *plusOne(int *digits, int digitsSize, int *returnSize) { for (int i = digitsSize - 1; i >= 0; i--) { if (digits[i] < 9) { digits[i]++; *returnSize = digitsSize; return digits; } else { digits[i] = 0; } } int *newdigit = (int *)malloc((digitsSize + 1) * sizeof(int)); newdigit[0] = 1; for (int i = 1; i < (digitsSize + 1); i++) { newdigit[i] = digits[i - 1]; } *returnSize = digitsSize + 1; return newdigit; }",
    "label": 0
  },
  {
    "code": "#include <stdio.h> #include <limits.h> #define MAXV 100 int graph8[MAXV][MAXV]; int distv[MAXV], visv[MAXV]; void dijkstra_v2(int n, int s){ for(int i=0;i<n;i++){ distv[i]=INT_MAX; visv[i]=0; } distv[s]=0; for(int i=0;i<n-1;i++){ int u=-1, min=INT_MAX; for(int j=0;j<n;j++) if(!visv[j] && distv[j]<min){ min=distv[j]; u=j; } if(u==-1) break; visv[u]=1; for(int v=0;v<n;v++) if(graph8[u][v] && distv[u]+graph8[u][v]<distv[v]) distv[v]=distv[u]+graph8[u][v]; } } #ifdef DEMO int main(){ int n=5; int mat[5][5]={{0,10,0,0,5},{0,0,1,0,2},{0,0,0,4,0},{7,0,6,0,0},{0,3,9,2,0}}; for(int i=0;i<n;i++) for(int j=0;j<n;j++) graph8[i][j]=mat[i][j]; dijkstra_v2(n,0); for(int i=0;i<n;i++) printf(\"dist[%d]=%d\\n\",i,distv[i]); return 0; } #endif",
    "label": 1
  },
  {
    "code": "#include <stdio.h> static void swap(int *x, int *y){ int t=*x; *x=*y; *y=t; } static int partition_hoare(int a[], int l, int r){ int pivot = a[l + (r - l)/2]; int i = l - 1, j = r + 1; for(;;){ do { ++i; } while(a[i] < pivot); do { --j; } while(a[j] > pivot); if(i >= j) return j; swap(&a[i], &a[j]); } } void quickSort(int a[], int l, int r){ if(l < r){ int p = partition_hoare(a, l, r); quickSort(a, l, p); quickSort(a, p+1, r); } } #ifdef DEMO int main(){ int a[] = {5,1,9,3,7,2,6,4,8,0}; int n = sizeof(a)/sizeof(a[0]); quickSort(a,0,n-1); for(int i=0;i<n;i++) printf(\"%d \", a[i]); return 0; } #endif",
    "label": 1
  },
  {
    "code": "int removeElement(int *nums, int numsSize, int val) { int i, start = 0; for (i = 0; i < numsSize; i++) { if (nums[i] != val) nums[start++] = nums[i]; } return start; }",
    "label": 0
  },
  {
    "code": "struct ListNode *deleteDuplicates(struct ListNode *head) { if (head == NULL) return NULL; if (head->next && head->val == head->next->val) { while (head->next && head->val == head->next->val) { head = head->next; } return deleteDuplicates(head->next); } else { head->next = deleteDuplicates(head->next); } return head; }",
    "label": 0
  },
  {
    "code": "int strStr(char *haystack, char *needle) { int i = 0; int j = 0; int k = 0; int hlen = 0; int nlen = 0; if (needle == NULL || *needle == 0) return 0; if (haystack == NULL || *haystack == 0) return -1; hlen = strlen(haystack); nlen = strlen(needle); if (hlen < nlen) return -1; for (i = 0; i <= hlen - nlen; i++) { j = 0; if (haystack[i] != needle[j++]) continue; k = i + 1; for (; j < nlen; j++) { if (haystack[k] != needle[j]) { break; } else k++; } if (j == nlen) return i; } return -1; } void fill_overlap(char *needle, int len_needle, int *overlap) { int len = 0; int i = 0; overlap[0] = 0; for (i = 1; i < len_needle;) { if (needle[i] == needle[len]) { len++; overlap[i++] = len; } else { if (len) len = overlap[len - 1]; else overlap[i++] = 0; } } } int strStr(char *haystack, char *needle) { int i = 0; int j = 0; int len_needle = strlen(needle); int len_haystack = strlen(haystack); if (!len_needle) return 0; int overlap[len_needle]; fill_overlap(needle, len_needle, overlap); while (i < len_haystack) { if (needle[j] == haystack[i]) { i++; j++; } if (j == len_needle) { return (i - j); } else if (i < len_haystack && needle[j] != haystack[i]) { if (j != 0) j = overlap[j - 1]; else i = i + 1; } } return -1; }",
    "label": 0
  },
  {
    "code": "int maxNumberOfBalloons(char *text) { int count_letters[5] = {0}; int i, min_counter_ballons; for (char *ptr = text; *ptr; ptr++) { if (*ptr == 'b') { count_letters[0]++; } else if (*ptr == 'a') { count_letters[1]++; } else if (*ptr == 'l') { count_letters[2]++; } else if (*ptr == 'o') { count_letters[3]++; } else if (*ptr == 'n') { count_letters[4]++; } } count_letters[2] /= 2; count_letters[3] /= 2; min_counter_ballons = count_letters[0]; for (i = 1; i < 5; i++) { if (count_letters[i] < min_counter_ballons) min_counter_ballons = count_letters[i]; } return min_counter_ballons; }",
    "label": 0
  },
  {
    "code": "#define min(a,b) (((a)<(b))?(a):(b)) #define max(a,b) (((a)>(b))?(a):(b)) int maxIncreaseKeepingSkyline(int** grid, int gridSize, int* gridColSize){ int* rowsMaxs = calloc(gridSize, sizeof(int)); int* colsMaxs = calloc(gridSize, sizeof(int)); for(int i = 0; i < gridSize; i++){ for (int j = 0; j < gridSize; j++){ rowsMaxs[i] = max(rowsMaxs[i], grid[i][j]); colsMaxs[j] = max(colsMaxs[j], grid[i][j]); } } int result = 0; for(int i = 0; i < gridSize; i++){ for (int j = 0; j < gridSize; j++){ int rowMax = rowsMaxs[i]; int colMax = colsMaxs[j]; result += min(rowMax - grid[i][j], colMax - grid[i][j]); } } free(rowsMaxs); free(colsMaxs); return result; }",
    "label": 0
  },
  {
    "code": "#include <stdio.h> static int feasible(int w[], int n, int days, int cap){ int need=1, cur=0; for(int i=0;i<n;i++){ if(w[i] > cap) return 0; if(cur + w[i] > cap){ need++; cur = 0; } cur += w[i]; } return need <= days; } int min_capacity(int w[], int n, int days){ int lo=1, hi=0; for(int i=0;i<n;i++){ if(w[i]>lo) lo=w[i]; hi+=w[i]; } while(lo < hi){ int mid = lo + (hi - lo)/2; if(feasible(w,n,days,mid)) hi = mid; else lo = mid + 1; } return lo; } #ifdef DEMO int main(){ int w[]={1,2,3,4,5,6,7,8,9,10}; printf(\"%d\\n\", min_capacity(w,10,5)); return 0; } #endif",
    "label": 1
  },
  {
    "code": "int maxval(int a, int b) { if (a > b) return a; else return b; } int maxDepth(struct TreeNode *root) { if (root == NULL) return 0; else return 1 + maxval(maxDepth(root->left), maxDepth(root->right)); }",
    "label": 0
  },
  {
    "code": "#include <stdio.h> void rotate90_cycles(int a[][100], int n){ for(int s=0; s<n/2; ++s){ int e = n - 1 - s; for(int k=0; k<e-s; ++k){ int tmp = a[s][s+k]; a[s][s+k] = a[e-k][s]; a[e-k][s] = a[e][e-k]; a[e][e-k] = a[s+k][e]; a[s+k][e] = tmp; } } } #ifdef DEMO int main(){ int n=5; int a[100][100]={{1,2,3,4,5},{6,7,8,9,10},{11,12,13,14,15},{16,17,18,19,20},{21,22,23,24,25}}; rotate90_cycles(a,n); for(int i=0;i<n;i++){ for(int j=0;j<n;j++) printf(\"%d \",a[i][j]); printf(\"\\n\"); } return 0; } #endif",
    "label": 1
  },
  {
    "code": "struct TreeNode *newNode(int item) { struct TreeNode *node = (struct TreeNode *)malloc(sizeof(struct TreeNode)); node->val = item; node->left = node->right = NULL; return node; } struct TreeNode *mergeTrees(struct TreeNode *t1, struct TreeNode *t2) { if (t1 == NULL && t2 == NULL) return NULL; int item = (t1 == NULL ? 0 : t1->val) + (t2 == NULL ? 0 : t2->val); struct TreeNode *node = newNode(item); node->left = mergeTrees(t1 == NULL ? NULL : t1->left, t2 == NULL ? NULL : t2->left); node->right = mergeTrees(t1 == NULL ? NULL : t1->right, t2 == NULL ? NULL : t2->right); return node; }",
    "label": 0
  },
  {
    "code": "int findComplement(int num) { int TotalBits = 0; int temp = num; while (temp) { TotalBits++; temp >>= 1; } int i, flipNumber = 1; for (i = 1; i < TotalBits; i++) { flipNumber += UINT32_C(1) << i; } num = num ^ flipNumber; return num; }",
    "label": 0
  },
  {
    "code": "#include <stdio.h> int upper_bound(int a[], int n, int target){ int lo=0, hi=n; while(lo < hi){ int mid = lo + (hi - lo)/2; if(a[mid] <= target) lo = mid + 1; else hi = mid; } return lo; } int last_occurrence(int a[], int n, int target){ int u = upper_bound(a,n,target); if(u-1 >=0 && u-1<n && a[u-1]==target) return u-1; return -1; } #ifdef DEMO int main(){ int a[]={1,2,4,4,4,5,7,9}; printf(\"ub(4)=%d last(4)=%d\\n\", upper_bound(a,8,4), last_occurrence(a,8,4)); return 0; } #endif",
    "label": 1
  },
  {
    "code": "bool isPalindrome(char *s) { int start = 0, end = strlen(s) - 1; while (start < end) { if (!isalpha(s[start]) && !isalnum(s[start])) { start++; } else if (!isalpha(s[end]) && !isalnum(s[end])) { end--; } else { char c1 = tolower(s[start]); char c2 = tolower(s[end]); if (c1 != c2) return 0; start++; end--; } } return 1; }",
    "label": 0
  },
  {
    "code": "#include <stdio.h> #include <stdlib.h> #define MAXN 1000 int adj[MAXN][MAXN], indeg[MAXN], q[MAXN]; void topo_kahn(int n){ int front=0, rear=0; for(int i=0;i<n;i++) if(indeg[i]==0) q[rear++]=i; while(front<rear){ int u=q[front++]; printf(\"%d \", u); for(int v=0;v<n;v++){ if(adj[u][v]){ if(--indeg[v]==0) q[rear++]=v; } } } printf(\"\\n\"); } #ifdef DEMO int main(){ int n=6; int edges[][2]={{5,2},{5,0},{4,0},{4,1},{2,3},{3,1}}; for(int i=0;i<6;i++) for(int j=0;j<6;j++) adj[i][j]=0; for(int i=0;i<6;i++){ adj[edges[i][0]][edges[i][1]]=1; indeg[edges[i][1]]++; } topo_kahn(n); return 0; } #endif",
    "label": 1
  },
  {
    "code": "char findTheDifference(char *s, char *t) { int sum1 = 0, sum2 = 0; int i; for (i = 0; i < strlen(s); i++) sum1 += s[i]; for (i = 0; i < strlen(t); i++) sum2 += t[i]; return (char)(sum2 - sum1); }",
    "label": 0
  },
  {
    "code": "#define max(X, Y) ((X) > (Y) ? (X) : (Y)) int maximizeTarget(char * answerKey, char targetChar, int k){ int leftIndex = -1; int result = 0; int currTargetChars = 0; int lenAnswerKey = strlen(answerKey); for (int rightIndex = 0; rightIndex < lenAnswerKey; rightIndex++){ char ch = answerKey[rightIndex]; if (ch == targetChar){ currTargetChars++; } while (rightIndex - leftIndex > currTargetChars + k) { leftIndex++; if (answerKey[leftIndex] == targetChar){ currTargetChars--; } } result = max(result, rightIndex - leftIndex); } return result; } int maxConsecutiveAnswers(char * answerKey, int k){ return max(maximizeTarget(answerKey, 'T', k), maximizeTarget(answerKey, 'F', k)); }",
    "label": 0
  },
  {
    "code": "bool isBadVersion(int version); int firstBadVersion(int n) { int low = 1, high = n; while (low <= high) { int mid = low + (high - low) / 2; if (isBadVersion(mid)) { high = mid - 1; } else { low = mid + 1; } } return low; }",
    "label": 0
  },
  {
    "code": "int *twoSum(int *nums, int numsSize, int target, int *returnSize) { int i, j; int *ret = calloc(2, sizeof(int)); for (i = 0; i < numsSize; i++) { int key = target - nums[i]; for (j = i + 1; j < numsSize; j++) if (nums[j] == key) { ret[0] = i; ret[1] = j; } } *returnSize = 2; return ret; }",
    "label": 0
  },
  {
    "code": "int maxcmp(int a, int b) { return a >= b ? a : b; } int maxSubArray(int *nums, int numsSize) { int maxSoFar = nums[0], maxEndingHere = nums[0]; for (int i = 1; i < numsSize; i++) { maxEndingHere = maxcmp(maxEndingHere + nums[i], nums[i]); maxSoFar = maxcmp(maxSoFar, maxEndingHere); } return maxSoFar; }",
    "label": 0
  },
  {
    "code": "long numberOfWaysForChar(char * s, char c){ long firstBuildingAppearNumber = 0; long secondBuildingAppearNumber = 0; long result = 0; int sLength = strlen(s); for (int i = 0; i < sLength; i++){ if (s[i] == c){ result += secondBuildingAppearNumber; firstBuildingAppearNumber += 1; continue; } secondBuildingAppearNumber += firstBuildingAppearNumber; } return result; } long long numberOfWays(char * s){ return numberOfWaysForChar(s, '0') + numberOfWaysForChar(s, '1'); }",
    "label": 0
  },
  {
    "code": "int minimumAverageDifference(int* nums, int numsSize){ long numsSum = 0; for (int i = 0; i < numsSize; i++){ numsSum += nums[i]; } long currSum = 0; long minAverage = 9223372036854775807; int minIndex = 0; for (int i = 0; i < numsSize; i++){ currSum += nums[i]; int leftItemsNumber = (numsSize - i - 1); long leftItemsNumberAverage = 0; if (leftItemsNumber != 0){ leftItemsNumberAverage = (numsSum - currSum) / leftItemsNumber; } long currItemsNumberAverage = currSum / (i + 1); long averageDiff = abs(currItemsNumberAverage - leftItemsNumberAverage); if (averageDiff < minAverage){ minAverage = averageDiff; minIndex = i; } } return minIndex; }",
    "label": 0
  },
  {
    "code": "int fib(int N) { if (N == 0) return 0; if (N == 1) return 1; return fib(N - 1) + fib(N - 2); }",
    "label": 0
  },
  {
    "code": "void processTraversal(struct TreeNode *root, int *res, int *size) { if (!root) return; processTraversal(root->left, res, size); res[*size] = root->val; *size = *size + 1; processTraversal(root->right, res, size); } int *inorderTraversal(struct TreeNode *root, int *returnSize) { int *res = malloc(256 * sizeof(int)); *returnSize = 0; processTraversal(root, res, returnSize); return res; }",
    "label": 0
  },
  {
    "code": "int hammingWeight(uint32_t n) { int TotalBits = 32; int i, weight = 0; for (i = 0; i < TotalBits; i++) { if (n & (UINT32_C(1) << i)) weight += 1; } return weight; }",
    "label": 0
  },
  {
    "code": "#include <stdio.h> int binary_search(int a[], int n, int target){ int lo = 0, hi = n - 1; while(lo <= hi){ int mid = lo + (hi - lo)/2; if(a[mid] == target) return mid; if(a[mid] < target) lo = mid + 1; else hi = mid - 1; } return -1; } #ifdef DEMO int main(){ int a[]={1,2,4,4,5,7,9}, n=7; printf(\"%d\\n\", binary_search(a,n,4)); printf(\"%d\\n\", binary_search(a,n,6)); return 0; } #endif",
    "label": 1
  },
  {
    "code": "#include <stdio.h> void rotate90(int **, int); static void transpose(int m[][100], int n){ for(int i=0;i<n;i++) for(int j=i+1;j<n;j++){ int t = m[i][j]; m[i][j] = m[j][i]; m[j][i] = t; } } static void reverse_row(int m[][100], int n, int r){ int i=0, j=n-1; while(i<j){ int t=m[r][i]; m[r][i]=m[r][j]; m[r][j]=t; ++i; --j; } } void rotate90_clockwise(int m[][100], int n){ transpose(m,n); for(int r=0;r<n;r++) reverse_row(m,n,r); } #ifdef DEMO int main(){ int n=3; int a[100][100]={{1,2,3},{4,5,6},{7,8,9}}; rotate90_clockwise(a,n); for(int i=0;i<n;i++){ for(int j=0;j<n;j++) printf(\"%d \",a[i][j]); printf(\"\\n\"); } return 0; } #endif",
    "label": 1
  },
  {
    "code": "int getPointKey(int i, int j, int boardSize, int boardColSize){ return boardSize * boardColSize * i + j; } const int directionsSize = 4; const int directions[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; bool exitsWord(int i, int j, char** board, int boardSize, int* boardColSize, int wordIndex, char* word, int* vistedPointSet){ if (board[i][j] != word[wordIndex]){ return false; } if (wordIndex == strlen(word) - 1){ return true; } for (int k = 0; k < directionsSize; k++){ int nextI = i + directions[k][0]; int nextJ = j + directions[k][1]; if (nextI < 0 || nextI >= boardSize || nextJ < 0 || nextJ >= boardColSize[i]){ continue; } int key = getPointKey(nextI, nextJ, boardSize, boardColSize[i]); if (vistedPointSet[key] == 1){ continue; } vistedPointSet[key] = 1; if (exitsWord(nextI, nextJ, board, boardSize, boardColSize, wordIndex + 1, word, vistedPointSet)){ return true; } vistedPointSet[key] = 0; } return false; } bool exist(char** board, int boardSize, int* boardColSize, char* word){ int* vistedPointSet = (int*) calloc(getPointKey(boardSize, boardColSize[0], boardSize, boardColSize[0]), sizeof(int)); for (int i = 0; i < boardSize; i++){ for (int j = 0; j < boardColSize[i]; j++){ int key = getPointKey(i, j, boardSize, boardColSize[i]); vistedPointSet[key] = 1; if (exitsWord(i, j, board, boardSize, boardColSize, 0, word, vistedPointSet)){ return true; }; vistedPointSet[key] = 0; } } return false; }",
    "label": 0
  },
  {
    "code": "int cmpval(const void *a, const void *b) { return *(int *)a - *(int *)b; } int *findDuplicates(int *nums, int numsSize, int *returnSize) { int i; qsort(nums, numsSize, sizeof(int), cmpval); int *retArr = malloc(numsSize * sizeof(int)); *returnSize = 0; for (i = 0; i < numsSize - 1;) { if (nums[i] == nums[i + 1]) { retArr[*returnSize] = nums[i]; *returnSize = *returnSize + 1; i = i + 2; } else { i = i + 1; } } return retArr; }",
    "label": 0
  },
  {
    "code": "struct ListNode *removeNthFromEnd(struct ListNode *head, int n) { struct ListNode entry, *p_free, *p = head; int i, sz = 0; entry.next = head; while (p != NULL) { p = p->next; sz++; } for (i = 0, p = &entry; i < sz - n; i++, p = p -> next) ; p_free = p->next; if (n != 1) { p->next = p->next->next; } else { p->next = NULL; } free(p_free); return entry.next; }",
    "label": 0
  },
  {
    "code": "#include <stdio.h> #include <stdlib.h> #include <limits.h> typedef struct { int v,w; struct Node* next; } Node; typedef struct { int u,d; } Pair; Node* adj8[100]; int dist8[100], vis8[100]; Pair heap8[1000]; int hsize8=0; void push(Node** h,int v,int w){ Node* n=malloc(sizeof(Node)); n->v=v; n->w=w; n->next=*h; *h=n; } void heapPush(Pair x){ heap8[++hsize8]=x; for(int i=hsize8;i>1 && heap8[i].d<heap8[i/2].d;i/=2){ Pair t=heap8[i]; heap8[i]=heap8[i/2]; heap8[i/2]=t; } } Pair heapPop(){ Pair ret=heap8[1]; heap8[1]=heap8[hsize8--]; for(int i=1;;){ int l=i*2,r=i*2+1,m=i; if(l<=hsize8 && heap8[l].d<heap8[m].d) m=l; if(r<=hsize8 && heap8[r].d<heap8[m].d) m=r; if(m==i) break; Pair t=heap8[i]; heap8[i]=heap8[m]; heap8[m]=t; i=m; } return ret; } void dijkstra(int n,int s){ for(int i=0;i<n;i++) dist8[i]=INT_MAX; dist8[s]=0; heapPush((Pair){s,0}); while(hsize8){ Pair p=heapPop(); int u=p.u; if(vis8[u]) continue; vis8[u]=1; Node* cur=adj8[u]; while(cur){ if(dist8[u]+cur->w<dist8[cur->v]){ dist8[cur->v]=dist8[u]+cur->w; heapPush((Pair){cur->v,dist8[cur->v]}); } cur=cur->next; } } } #ifdef DEMO int main(){ int n=5; push(&adj8[0],1,10); push(&adj8[0],4,5); push(&adj8[1],2,1); push(&adj8[1],4,2); push(&adj8[2],3,4); push(&adj8[3],0,7); push(&adj8[3],2,6); push(&adj8[4],1,3); push(&adj8[4],2,9); push(&adj8[4],3,2); dijkstra(n,0); for(int i=0;i<n;i++) printf(\"0->%d=%d\\n\", i, dist8[i]); return 0; } #endif",
    "label": 1
  },
  {
    "code": "int romanToInt(char *s) { int romanToInt = 0; for (int i = 0; i < strlen(s); i++) { switch (s[i]) { case 'I': if (i + 1 < strlen(s)) { if (s[i + 1] == 'V' || s[i + 1] == 'X') { romanToInt -= 1; break; } } romanToInt += 1; break; case 'V': romanToInt += 5; break; case 'X': if (i + 1 < strlen(s)) { if (s[i + 1] == 'L' || s[i + 1] == 'C') { romanToInt -= 10; break; } } romanToInt += 10; break; case 'L': romanToInt += 50; break; case 'C': if (i + 1 < strlen(s)) { if (s[i + 1] == 'D' || s[i + 1] == 'M') { romanToInt -= 100; break; } } romanToInt += 100; break; case 'D': romanToInt += 500; break; case 'M': romanToInt += 1000; break; default: break; } } return romanToInt; }",
    "label": 0
  },
  {
    "code": "#define min(x, y) (((x) < (y)) ? (x) : (y)) bool isWordLess(char* word1, char* word2, int* charOrder){ int word1Length = strlen(word1); int word2Length = strlen(word2); for(int i = 0; i < min(word1Length, word2Length); i++) { int charWordsDiff = (charOrder[word1[i] - 'a'] - charOrder[word2[i] - 'a']); if (charWordsDiff < 0){ return true; } if (charWordsDiff > 0){ return false; } } return word1Length <= word2Length; } bool isAlienSorted(char ** words, int wordsSize, char * order){ const int lowerCaseLettersNumber = 26; int charorder[lowerCaseLettersNumber]; for(int i = 0; i < lowerCaseLettersNumber; i++) { charorder[order[i] - 'a'] = i; } for(int i = 0; i < wordsSize - 1; i++) { if (!isWordLess(words[i], words[i + 1], charorder)){ return false; } } return true; }",
    "label": 0
  },
  {
    "code": "int countSubstrings(char *s) { int len = strlen(s); int i; int count = 0; for (i = 0; i < len; i++) { count += countPalin(s, i, i, len); if (i != len - 1) count += countPalin(s, i, i + 1, len); } return count; } int countPalin(char *s, int head, int tail, int len) { int ret = (s[head] == s[tail]) ? 1 : 0; if (ret && head - 1 >= 0 && tail + 1 < len) ret += countPalin(s, head - 1, tail + 1, len); return ret; }",
    "label": 0
  },
  {
    "code": "bool checkIsBst(struct TreeNode* node, bool leftBoundInf, int leftBound, bool rightBoundInf, int rightBound){ return (node == NULL) || (leftBoundInf || node->val > leftBound) && (rightBoundInf || node->val < rightBound) && checkIsBst(node->left, leftBoundInf, leftBound, false, node->val) && checkIsBst(node->right, false, node->val, rightBoundInf, rightBound); } bool isValidBST(struct TreeNode* root){ return checkIsBst(root, true, INT_MIN, true, INT_MAX); }",
    "label": 0
  },
  {
    "code": "#include <stdio.h> void rotate90_extra(int src[][100], int dst[][100], int n){ for(int i=0;i<n;i++) for(int j=0;j<n;j++) dst[j][n-1-i] = src[i][j]; } #ifdef DEMO int main(){ int n=3; int a[100][100]={{1,2,3},{4,5,6},{7,8,9}}, b[100][100]={0}; rotate90_extra(a,b,n); for(int i=0;i<n;i++){ for(int j=0;j<n;j++) printf(\"%d \",b[i][j]); printf(\"\\n\"); } return 0; } #endif",
    "label": 1
  },
  {
    "code": "#include <limits.h> typedef struct { int *values; int CurrentIndex; int NumberOfNodes; } BSTIterator; void TraverseAndAssign(struct TreeNode *root, BSTIterator *obj) { if (!root) return; if (root->left) TraverseAndAssign(root->left, obj); obj->values[obj->CurrentIndex] = root->val; obj->CurrentIndex++; if (root->right) TraverseAndAssign(root->right, obj); } int TotalNodes(struct TreeNode *root) { if (!root) return 0; int nodes_left = TotalNodes(root->left); int nodes_right = TotalNodes(root->right); return nodes_left + nodes_right + 1; } BSTIterator *bSTIteratorCreate(struct TreeNode *root) { int n = TotalNodes(root); int size = n + 1; printf(\"%d\", size); BSTIterator *obj = (BSTIterator *)malloc(sizeof(BSTIterator)); obj->values = (int *)calloc(size, sizeof(int)); obj->CurrentIndex = 0; obj->NumberOfNodes = n; obj->values[size - 1] = INT_MAX; TraverseAndAssign(root, obj); obj->CurrentIndex = 0; return obj; } int bSTIteratorNext(BSTIterator *obj) { int NextValue = obj->values[obj->CurrentIndex]; obj->CurrentIndex++; return NextValue; } bool bSTIteratorHasNext(BSTIterator *obj) { if (!obj->NumberOfNodes) { return false; } printf(\" Here \"); return (obj->values[obj->CurrentIndex] == INT_MAX) ? false : true; } void bSTIteratorFree(BSTIterator *obj) { free(obj->values); free(obj); }",
    "label": 0
  },
  {
    "code": "bool isleaf(struct TreeNode *root) { return root->left == NULL && root->right == NULL; } int sumOfLeftLeaves(struct TreeNode *root) { if (root == NULL) return 0; if (root->left) { if (isleaf(root->left)) return root->left->val + sumOfLeftLeaves(root->right); } return sumOfLeftLeaves(root->left) + sumOfLeftLeaves(root->right); }",
    "label": 0
  },
  {
    "code": "#define max(a,b) (((a)>(b))?(a):(b)) int longestSquareStreakDp(int* numsSet, int numsSetSize, int* dp, long num){ if (dp[num] != 0){ return dp[num]; } long numSquare = num * num; dp[num] = 1; if (numSquare <= numsSetSize && numsSet[numSquare] == 1){ dp[num] += longestSquareStreakDp(numsSet, numsSetSize, dp, numSquare); } return dp[num]; } int longestSquareStreak(int* nums, int numsSize){ int numMax = 0; for(int i = 0; i < numsSize; i++){ numMax = max(numMax, nums[i]); } int* numsSet = calloc(numMax + 1, sizeof(int)); int* dp = calloc(numMax + 1, sizeof(int)); for(int i = 0; i < numsSize; i++){ numsSet[nums[i]] = 1; } int result = -1; for(int i = 0; i < numsSize; i++){ long num = nums[i]; long numSquare = num * num; if (numSquare > numMax || numsSet[numSquare] == 0){ continue; } result = max(result, 1 + longestSquareStreakDp(numsSet, numMax, dp, numSquare)); } free(dp); free(numsSet); return result; }",
    "label": 0
  },
  {
    "code": "struct ListNode *reverse(struct ListNode *head) { struct ListNode *res = NULL; while (head) { struct ListNode *pre_node = head; head = head->next; pre_node->next = res; res = pre_node; } return res; } bool isPalindrome(struct ListNode *head) { struct ListNode *slow = head; struct ListNode *fast = head; struct ListNode *last; while (fast && fast->next) { slow = slow->next; fast = fast->next->next; } if (fast != NULL) slow = slow->next; last = reverse(slow); while (last) { if (head->val != last->val) return 0; head = head->next; last = last->next; } return 1; }",
    "label": 0
  },
  {
    "code": "#include <stdio.h> long count_subarrays_k_twoptr(int a[], int n, int k){ int l=0; long sum=0, ans=0; for(int r=0;r<n;r++){ sum += a[r]; while(l<=r && sum > k){ sum -= a[l++]; } if(sum==k){ ans++; sum -= a[l++]; } } return ans; } #ifdef DEMO int main(){ int a[]={1,2,1,1,1}; int n=5,k=3; printf(\"%ld\\n\", count_subarrays_k_twoptr(a,n,k)); return 0; } #endif",
    "label": 1
  },
  {
    "code": "int missingNumber(int *nums, int numsSize) { int i, actual_sum = 0, sum = 0; for (i = 0; i < numsSize; i++) { sum = sum + nums[i]; actual_sum = actual_sum + i; } return actual_sum + numsSize - sum; }",
    "label": 0
  },
  {
    "code": "#include <stdio.h> static void swap(int *a, int *b){ int t=*a; *a=*b; *b=t; } static void quick3(int a[], int l, int r){ if(l >= r) return; int lt = l, i = l+1, gt = r; int pivot = a[l]; while(i <= gt){ if(a[i] < pivot){ swap(&a[i++], &a[lt++]); } else if(a[i] > pivot){ swap(&a[i], &a[gt--]); } else { i++; } } quick3(a, l, lt-1); quick3(a, gt+1, r); } void quickSort(int a[], int l, int r){ quick3(a,l,r); } #ifdef DEMO int main(){ int a[]={2,3,2,1,2,3,2,1,2,3,2}; int n=sizeof(a)/sizeof(a[0]); quickSort(a,0,n-1); for(int i=0;i<n;i++) printf(\"%d \", a[i]); return 0; } #endif",
    "label": 1
  },
  {
    "code": "bool hasCycle(struct ListNode *head) { struct ListNode *fast = head, *slow = head; while (slow && fast && fast->next) { fast = fast->next->next; slow = slow->next; if (fast == slow) return true; } return false; }",
    "label": 0
  },
  {
    "code": "int lengthOfLongestSubstring(char *str) { int n = strlen(str); if (!n) return 0; int L_len = 1; int C_len = 1; int P_ind, i; int visited[256]; memset(visited, -1, sizeof(int) * 256); visited[str[0]] = 0; for (i = 1; i < n; i++) { P_ind = visited[str[i]]; if (P_ind == -1 || i - C_len > P_ind) C_len++; else { if (C_len > L_len) L_len = C_len; C_len = i - P_ind; } visited[str[i]] = i; } if (C_len > L_len) L_len = C_len; return L_len; } int lengthOfLongestSubstring(char *s) { int cur_max = 0, max = 0; int counter[255]; int end = 0; memset(counter, 0, sizeof(int) * 255); while (end < strlen(s)) { if (counter[s[end]] == 0) { counter[s[end]]++; end++; cur_max++; } else { char c = s[end]; memset(counter, 0, 255 * sizeof(int)); if (cur_max >= max) max = cur_max; cur_max = 0; while (s[end - 1] != c) end--; } } if (cur_max >= max) max = cur_max; return max; }",
    "label": 0
  },
  {
    "code": "int myAtoi(char *str) { int minusFlag = 0; int length = strlen(str); long int result = 0; char numberBuffer[11]; int counter = 0; while (str[counter] == ' ') { counter++; } str = &str[counter]; counter = 0; for (int i = 0; i < length; i++) { if (i == 0) { if (str[0] == '-') { minusFlag = 1; i++; } else if (str[0] == '+') { i++; } } if (counter > 10) { if (minusFlag) { return __INT_MAX__ * -1 - 1; } else { return __INT_MAX__; } } if (str[i] < '0' || str[i] > '9') { break; } if (counter == 0 && str[i] == '0') { continue; } numberBuffer[counter] = str[i]; counter++; } int i = 0; while (counter > 0) { if (minusFlag) { result -= (numberBuffer[i] - '0') * pow(10.0, counter - 1); } else { result += (numberBuffer[i] - '0') * pow(10.0, counter - 1); } i++; counter--; } if (result > __INT_MAX__) { return __INT_MAX__; } else if (result < __INT_MAX__ * -1 - 1) { return __INT_MAX__ * -1 - 1; } return result; }",
    "label": 0
  },
  {
    "code": "char *reverseOnlyLetters(char *S) { int last = strlen(S) - 1, i; for (i = 0; i < last;) { if (!isalpha(S[i])) { i++; continue; } if (!isalpha(S[last])) { last--; continue; } char tmp = S[i]; S[i] = S[last]; S[last] = tmp; i++; last--; } return S; }",
    "label": 0
  },
  {
    "code": "int searchInsert(int *nums, int numsSize, int target) { int low = 0, high = numsSize - 1, mid; while (low <= high) { mid = low + (high - low) / 2; if (target > nums[mid]) low = mid + 1; else if (target < nums[mid]) high = mid - 1; else return mid; } return low; } int searchInsert(int *nums, int numsSize, int target) { int idx = numsSize - 1; if (numsSize > 0) { if (target > nums[idx]) { return numsSize; } return searchInsert(nums, numsSize - 1, target); } return 0; }",
    "label": 0
  },
  {
    "code": "#include <stdio.h> int lower_bound(int a[], int n, int target){ int lo=0, hi=n; while(lo < hi){ int mid = lo + (hi - lo)/2; if(a[mid] < target) lo = mid + 1; else hi = mid; } return lo; } #ifdef DEMO int main(){ int a[]={1,2,4,4,5,7,9}; for(int t=0;t<=10;++t){ printf(\"lb(%d)=%d\\n\", t, lower_bound(a,7,t)); } return 0; } #endif",
    "label": 1
  },
  {
    "code": "bool checkSymmetric(struct TreeNode *left, struct TreeNode *right) { if (!left || !right) return left == right; if (left->val != right->val) return 0; return checkSymmetric(left->left, right->right) && checkSymmetric(left->right, right->left); } bool isSymmetric(struct TreeNode *root) { return root == NULL || checkSymmetric(root->left, root->right); }",
    "label": 0
  },
  {
    "code": "int max(int a, int b) { return a >= b ? a : b; } int height(struct TreeNode *root) { if (root == NULL) return 0; else return 1 + max(height(root->left), height(root->right)); } bool isBalanced(struct TreeNode *root) { if (root == NULL) return 1; int left = height(root->left); int right = height(root->right); return abs(left - right) <= 1 && isBalanced(root->left) && isBalanced(root->right); }",
    "label": 0
  },
  {
    "code": "bool hasPathSum(struct TreeNode *root, int sum) { if (root == NULL) return 0; if (!root->left && !root->right && sum - root->val == 0) return 1; return hasPathSum(root->left, sum - root->val) || hasPathSum(root->right, sum - root->val); }",
    "label": 0
  },
  {
    "code": "#include <stdio.h> int lis_clarity(int arr[], int n){ int lengthAt[1005]; int maxLen = 0; for(int i=0;i<n;i++){ lengthAt[i] = 1; for(int j=0;j<i;j++){ if(arr[j] < arr[i]){ int candidate = lengthAt[j] + 1; if(candidate > lengthAt[i]) lengthAt[i] = candidate; } } if(lengthAt[i] > maxLen) maxLen = lengthAt[i]; } return maxLen; } #ifdef DEMO int main(){ int a[]={1,3,6,7,9,4,10,5,6}; printf(\"%d\\n\", lis_clarity(a,9)); return 0; } #endif",
    "label": 1
  },
  {
    "code": "int waysToSplitArray(int* nums, int numsSize){ long sumNums = 0; for (int i = 0; i < numsSize; i++){ sumNums += nums[i]; } long prefixSum = 0; int result = 0; for (int i = 0; i < numsSize - 1; i++){ prefixSum += nums[i]; if (prefixSum >= sumNums - prefixSum){ result += 1; } } return result; }",
    "label": 0
  },
  {
    "code": "#include <stdio.h> static inline void SWAP(int *x, int *y){ int t=*x; *x=*y; *y=t; } void rotate90_clean(int a[][100], int n){ for(int i=0;i<n;i++) for(int j=i+1;j<n;j++) SWAP(&a[i][j], &a[j][i]); for(int i=0;i<n;i++){ int l=0, r=n-1; while(l<r){ SWAP(&a[i][l], &a[i][r]); ++l; --r; } } } #ifdef DEMO int main(){ int n=2; int a[100][100]={{1,2},{3,4}}; rotate90_clean(a,n); for(int i=0;i<n;i++){ for(int j=0;j<n;j++) printf(\"%d \",a[i][j]); printf(\"\\n\"); } return 0; } #endif",
    "label": 1
  },
  {
    "code": "int hammingDistance(int x, int y) { int difference = x ^ y; int TotalBits = sizeof(difference) * 8; int i, distance = 0; for (i = 0; i < TotalBits; i++) { if (difference & (UINT32_C(1) << i)) distance += 1; } return distance; }",
    "label": 0
  },
  {
    "code": "int singleNonDuplicate(int* nums, int numsSize) { int left = 0, right = numsSize - 1; while (left < right) { int mid = (right + left) / 2; if (mid % 2 == 0) { if (nums[mid] == nums[mid + 1]) left = mid + 2; else right = mid; } else { if (nums[mid] == nums[mid - 1]) left = mid + 1; else right = mid - 1; } } return nums[left]; }",
    "label": 0
  },
  {
    "code": "int coundDevices(char* bankRow){ int result = 0; int bankRowSize = strlen(bankRow); for(int i = 0; i < bankRowSize; i++){ if (bankRow[i] == '1'){ result++; } } return result; } int numberOfBeams(char ** bank, int bankSize){ int prevRowDevices = 0; int result = 0; for(int i = 0; i < bankSize; i++){ int devices = coundDevices(bank[i]); if (devices == 0){ continue; } result += devices * prevRowDevices; prevRowDevices = devices; } return result; }",
    "label": 0
  },
  {
    "code": "int peakIndexInMountainArray(int *A, int ASize) { int low = 1, high = ASize; while (low <= high) { int mid = low + (high - low) / 2; if (A[mid - 1] < A[mid] && A[mid] > A[mid + 1]) return mid; else if (A[mid - 1] < A[mid] && A[mid] < A[mid + 1]) low = mid + 1; else high = mid - 1; } return -1; }",
    "label": 0
  },
  {
    "code": "int rangeBitwiseAnd(int m, int n) { while (m < n) { n &= n - 1; } return n; }",
    "label": 0
  },
  {
    "code": "bool isAnagram(char *s, char *t) { int n = strlen(s); int m = strlen(t); int cnt_s[1000], cnt_t[1000]; for (int c = 97; c < 97 + 26; c++) cnt_s[c] = cnt_t[c] = 0; for (int i = 0; i < n; i++) cnt_s[s[i]]++; for (int i = 0; i < m; i++) cnt_t[t[i]]++; for (int c = 97; c < 97 + 26; c++) if (cnt_s[c] != cnt_t[c]) return false; return true; }",
    "label": 0
  },
  {
    "code": "#include <stdlib.h> #include <string.h> char *get_letters(char digit) { switch (digit) { case '2': return \"abc\"; case '3': return \"def\"; case '4': return \"ghi\"; case '5': return \"jkl\"; case '6': return \"mno\"; case '7': return \"pqrs\"; case '8': return \"tuv\"; case '9': return \"wxyz\"; default: return \"\"; } } char **letterCombinations(char *digits, int *return_size) { char *cp; int i, j, k, l, ind, k_tot, l_tot, digits_size = 0; if (*digits == '\\0') { *return_size = 0; return NULL; } *return_size = 1; cp = digits; while (*cp != '\\0') { *return_size *= strlen(get_letters(*cp)); digits_size++; cp++; } char **combs = malloc(sizeof(char*) * (*return_size)); for (i = 0; i < *return_size; i++) { combs[i] = malloc(sizeof(char) * (digits_size + 1)); combs[i][digits_size] = '\\0'; } k_tot = 1; l_tot = (*return_size); for (i = 0; i < digits_size; i++) { cp = get_letters(digits[i]); l_tot /= strlen(cp); for (j = 0; j < strlen(cp); j++) { for (k = 0; k < k_tot; k++) { for (l = 0; l < l_tot; l++) { ind = k * l_tot * strlen(cp) + l + l_tot * j; combs[ind][i] = cp[j]; } } } k_tot *= strlen(cp); } return combs; }",
    "label": 0
  },
  {
    "code": "int maximumUniqueSubarray(int* nums, int numsSize){ short* numsSet = (short*)calloc(10001, sizeof(short)); numsSet[nums[0]] = 1; int maxSum = nums[0]; int windowSumm = maxSum; int leftIndex = 0; int num = 0; for(int i = 1; i < numsSize; i++){ num = nums[i]; while (numsSet[num] != 0){ numsSet[nums[leftIndex]] = 0; windowSumm -= nums[leftIndex]; leftIndex++; } numsSet[num] = 1; windowSumm += num; if (maxSum < windowSumm){ maxSum = windowSumm; } } return maxSum; }",
    "label": 0
  },
  {
    "code": "#include <stdio.h> #include <stdlib.h> typedef struct { long ps; int idx; } P; static int cmpP(const void* a, const void* b){ const P *x=a, *y=b; if(x->ps<y->ps) return -1; if(x->ps>y->ps) return 1; return x->idx - y->idx; } long count_subarrays_k_sorted(int a[], int n, int k){ P p[2005]; p[0].ps=0; p[0].idx=0; long s=0; for(int i=0;i<n;i++){ s+=a[i]; p[i+1].ps=s; p[i+1].idx=i+1; } P q[4005]; int m=0; for(int i=0;i<=n;i++){ q[m++] = (P){p[i].ps, i}; q[m++] = (P){p[i].ps - k, -(i+1)}; } qsort(q,m,sizeof(P),cmpP); long ans=0; long seen=0; for(int i=0;i<m;i++){ if(q[i].idx<0) seen++; else ans += seen; if(i+1<m && q[i+1].ps!=q[i].ps) seen=0; } return ans; } #ifdef DEMO int main(){ int a[]={1,2,3}; int n=3,k=3; printf(\"%ld\\n\", count_subarrays_k_sorted(a,n,k)); return 0; } #endif",
    "label": 1
  },
  {
    "code": "#include <stdio.h> #include <limits.h> #define NMAX 10 int graphM[NMAX][NMAX]; void dijkstra_verbose(int n,int s){ int dist[NMAX], vis[NMAX]; for(int i=0;i<n;i++){ dist[i]=INT_MAX; vis[i]=0; } dist[s]=0; for(int i=0;i<n-1;i++){ int u=-1,min=INT_MAX; for(int j=0;j<n;j++) if(!vis[j] && dist[j]<min){ min=dist[j]; u=j; } if(u==-1) break; vis[u]=1; printf(\"Visited %d\\n\",u); for(int v=0;v<n;v++){ if(graphM[u][v] && dist[u]+graphM[u][v]<dist[v]) dist[v]=dist[u]+graphM[u][v]; } } for(int i=0;i<n;i++) printf(\"dist[%d]=%d\\n\",i,dist[i]); } #ifdef DEMO int main(){ int n=4; int m[4][4]={{0,3,0,7},{0,0,4,2},{0,0,0,5},{0,0,0,0}}; for(int i=0;i<n;i++) for(int j=0;j<n;j++) graphM[i][j]=m[i][j]; dijkstra_verbose(n,0); return 0; } #endif",
    "label": 1
  },
  {
    "code": "int** generate(int numRows, int* returnSize, int** returnColumnSizes){ *returnSize = numRows; int **ans = (int**)malloc(numRows*sizeof(int*)); *returnColumnSizes = (int*)malloc(numRows*sizeof(int)); for (int i=0; i<numRows; i++) { (*returnColumnSizes)[i] = i + 1; ans[i] = (int*)malloc((i+1)*sizeof(int)); } ans[0][0] = 1; for (int i=1; i<numRows; i++) { ans[i][0] = 1; for (int j=1; j<i; j++) { ans[i][j] = ans[i-1][j-1] + ans[i-1][j]; } ans[i][i] = 1; } return ans; }",
    "label": 0
  },
  {
    "code": "int findMaxConsecutiveOnes(int* nums, int numsSize){ int i=0; int maxCount=0; int count = 0; while(i<numsSize){ while(i<numsSize && nums[i]!=0){ count++; i++; } if(maxCount<=count){ maxCount = count; } count = 0; while(i<numsSize && nums[i]==0){ i++; } } return maxCount; }",
    "label": 0
  },
  {
    "code": "#include <stdio.h> #include <string.h> long count_subarrays_divisible_by_k(int a[], int n, int K){ long freq[1005]; memset(freq,0,sizeof(freq)); long sum=0, ans=0; freq[0]=1; for(int i=0;i<n;i++){ sum += a[i]; int m = (int)((sum%K + K) % K); ans += freq[m]; freq[m]++; } return ans; } #ifdef DEMO int main(){ int a[]={4,5,0,-2,-3,1}; int n=6, K=5; printf(\"%ld\\n\", count_subarrays_divisible_by_k(a,n,K)); return 0; } #endif",
    "label": 1
  },
  {
    "code": "int countSegments(char * s){ int sLen = strlen(s); int prevSpace = 1; int result = 0; char currChar; for (int i = 0; i < sLen; i++){ currChar = s[i]; if (s[i] != ' ' && prevSpace) { result++; } prevSpace = (currChar == ' '); } return result; }",
    "label": 0
  },
  {
    "code": "int numcmp(const void *a, const void *b) { return *(int *)a - *(int *)b; } bool containsDuplicate(int *nums, int numsSize) { int i; qsort(nums, numsSize, sizeof(int), numcmp); for (i = 0; i < numsSize - 1; i++) { if (nums[i] == nums[i + 1]) return 1; } return 0; }",
    "label": 0
  },
  {
    "code": "const int EnglishLettersNumber = 26; void countCharsForStringSlice(int* charsCounter, char* s, int length, int sign) { for (int i = 0; i < length; i++) { charsCounter[s[i] - 'a'] += sign; } } bool checkInclusion(char* s1, char* s2) { int lengthS1 = strlen(s1); int lengthS2 = strlen(s2); if (lengthS1 > lengthS2) { return false; } int* charsCounter = calloc(EnglishLettersNumber, sizeof(int)); countCharsForStringSlice(charsCounter, s1, lengthS1, -1); countCharsForStringSlice(charsCounter, s2, lengthS1, 1); int diffChars = 0; for (int i = 0; i < EnglishLettersNumber; i++) { if (charsCounter[i] != 0) { diffChars++; } } if (diffChars == 0) { return true; } for (int i = 0; i < lengthS2 - lengthS1; i++) { int charNumberLeft = s2[i] - 'a'; int charNumberRight = s2[i + lengthS1] - 'a'; charsCounter[charNumberLeft] -= 1; if (charsCounter[charNumberLeft] == 0) { diffChars -= 1; } else if (charsCounter[charNumberLeft] == -1) { diffChars += 1; } charsCounter[charNumberRight] += 1; if (charsCounter[charNumberRight] == 0) { diffChars -= 1; } else if (charsCounter[charNumberRight] == 1) { diffChars += 1; } if (diffChars == 0) { return true; } } free(charsCounter); return false; }",
    "label": 0
  },
  {
    "code": "struct TreeNode *convertBST(int *nums, int left, int right) { if (left > right) return NULL; else { int mid = (right + left) / 2; struct TreeNode *new_val = malloc(sizeof(struct TreeNode)); new_val->val = nums[mid]; new_val->left = convertBST(nums, left, mid - 1); new_val->right = convertBST(nums, mid + 1, right); return new_val; } } struct TreeNode *sortedArrayToBST(int *nums, int numsSize) { if (numsSize == 0) return NULL; else return convertBST(nums, 0, numsSize - 1); }",
    "label": 0
  },
  {
    "code": "int bitwiseComplement(int n){ if (n == 0){ return 1; } int binary_number_length = ceil(log2(n)); return (~n) & ((1 << binary_number_length) - 1); }",
    "label": 0
  },
  {
    "code": "struct TreeNode* findKthSmallest(struct TreeNode* node, int* k){ if (node == NULL){ return NULL; } struct TreeNode* resultNode = findKthSmallest(node->left, k); if (resultNode != NULL){ return resultNode; } *k -= 1; if (*k == 0){ return node; } return findKthSmallest(node->right, k); } int kthSmallest(struct TreeNode* root, int k){ return findKthSmallest(root, &k)->val; }",
    "label": 0
  },
  {
    "code": "char *getOne(char c) { switch (c) { case '9': return \"IX\"; case '8': return \"VIII\"; case '7': return \"VII\"; case '6': return \"VI\"; case '5': return \"V\"; case '4': return \"IV\"; case '3': return \"III\"; case '2': return \"II\"; case '1': return \"I\"; case '0': return \"\"; default: return NULL; } } char *getTen(char c) { switch (c) { case '9': return \"XC\"; case '8': return \"LXXX\"; case '7': return \"LXX\"; case '6': return \"LX\"; case '5': return \"L\"; case '4': return \"XL\"; case '3': return \"XXX\"; case '2': return \"XX\"; case '1': return \"X\"; case '0': return \"\"; default: return NULL; } } char *getHundred(char c) { switch (c) { case '9': return \"CM\"; case '8': return \"DCCC\"; case '7': return \"DCC\"; case '6': return \"DC\"; case '5': return \"D\"; case '4': return \"CD\"; case '3': return \"CCC\"; case '2': return \"CC\"; case '1': return \"C\"; case '0': return \"\"; default: return NULL; } } char *getThousand(char c) { switch (c) { case '3': return \"MMM\"; case '2': return \"MM\"; case '1': return \"M\"; default: return NULL; } } char *intToRoman(int num) { int length; char number[5]; char *s = malloc(16 * sizeof(char)); sprintf(number, \"%i\", num); length = strlen(number); switch (length) { case 4: sprintf(s, \"%s%s%s%s\", getThousand(number[0]), getHundred(number[1]), getTen(number[2]), getOne(number[3])); break; case 3: sprintf(s, \"%s%s%s\", getHundred(number[0]), getTen(number[1]), getOne(number[2])); break; case 2: sprintf(s, \"%s%s\", getTen(number[0]), getOne(number[1])); break; case 1: s = getOne(number[0]); break; default: break; } return s; }",
    "label": 0
  },
  {
    "code": "int removeDuplicates(int *nums, int numsSize) { int count = 0, i; for (i = 1; i < numsSize; i++) { if (nums[i] == nums[i - 1]) count++; else nums[i - count] = nums[i]; } return numsSize - count; }",
    "label": 0
  },
  {
    "code": "#define max(a,b) (((a)>(b))?(a):(b)) #define min(a,b) (((a)<(b))?(a):(b)) void recursiveSolve(struct TreeNode* node, int* result, int minVal, int maxVal){ if (node == NULL){ return; } *result = max(*result, abs(minVal - node->val)); *result = max(*result, abs(maxVal - node->val)); minVal = min(minVal, node->val); maxVal = max(maxVal, node->val); recursiveSolve(node->left, result, minVal, maxVal); recursiveSolve(node->right, result, minVal, maxVal); } int maxAncestorDiff(struct TreeNode* root){ int result = 0; int maxVal = root->val; int minVal = root->val; recursiveSolve(root, &result, minVal, maxVal); return result; }",
    "label": 0
  },
  {
    "code": "int findMin(int *nums, int numsSize) { int low = 0, high = numsSize - 1; while (low < high) { int mid = low + (high - low) / 2; if (nums[mid] < nums[high]) high = mid; else low = mid + 1; } return nums[low]; }",
    "label": 0
  },
  {
    "code": "#define max(a,b) (((a)>(b))?(a):(b)) int recursiveSolve(struct TreeNode* node, int* result){ if (node == NULL){ return 0; } int leftSum = max(recursiveSolve(node->left, result), 0); int rightSum = max(recursiveSolve(node->right, result), 0); int maxValueNode = node->val + leftSum + rightSum; *result = max(maxValueNode, *result); return node->val + max(leftSum, rightSum); } int maxPathSum(struct TreeNode* root){ const int LOWER_BOUND = -2147483648 int result = LOWER_BOUND; recursiveSolve(root, &result); return result; }",
    "label": 0
  }
]